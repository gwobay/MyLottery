/*
 * 1.2 version.
 */

import java.io.*;
import java.util.Arrays;
/*
import java.util.*;
*/
import java.util.Date;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
//import java.util.regex.*;
import java.awt.*;
import java.text.DecimalFormat;
import java.awt.geom.*;

import javax.swing.*;

import java.awt.image.*;

import javax.imageio.*;

import java.io.File;
import java.util.Vector;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.io.IOException;
import java.lang.Thread;

/* 
 * This is like the FontDemo applet in volume 1, except that it 
 * uses the Java 2D APIs to define and render the graphics and text.
 *
 * read data file data5day generated by Script c.data5day
 */

public class HalfExpandedErrorTs extends JFrame implements Runnable 
{
/**
	
	 */
	private static final long serialVersionUID = 161720875199630789L;
	//start of program
	final static DecimalFormat dF=new DecimalFormat("0.00");
    final static int maxCharHeight = 30;
    final static int minFontSize = 12;
    final static int maxchartPoints = 400;

    final static Color bg = Color.white;
    final static Color fg = Color.black;
    final static Color red = Color.red;
    final static Color white = Color.white;

    final static BasicStroke stroke = new BasicStroke(2.0f);
    final static BasicStroke wideStroke = new BasicStroke(8.0f);

    final static float dash1[] = {10.0f};
    final static BasicStroke dashed = new BasicStroke(1.0f, 
                                                      BasicStroke.CAP_BUTT, 
                                                      BasicStroke.JOIN_MITER, 
                                                      10.0f, dash1, 0.0f);
	private static DecimalFormat dataF=new DecimalFormat("##.##");
	private static DecimalFormat dataIntF=new DecimalFormat("00");
	//static String DataSrc=new String("daily_d.txt");
    //static JFrame f;
	


    FontMetrics fontMetrics;
	static long today1stSecond=0, today930Second=0;

      
	
	Vector<String> myQuotes;
	String lastQuoteTime;
	static String mktStartTime="09:30";
	String samplingStartFrom;
	String samplingEnd;
	public String mySymbol;
	String YhSymb;
	int pVolume;
	int lastPVolTime;
	
	double priceMax, priceMin;
	int volDeltaMax, volDeltaMin;
	boolean testMode;
	String lastPrice;
	String lastVol;
	String lastChange;
	boolean isFileData;
   
	static int iMax=40;
	static int iMin=0;
	static int totalPoints=320;
	static int[] pointLine1=new int[maxchartPoints];
	static int[] pointLine2=new int[maxchartPoints];
	static int[] pointLine3=new int[maxchartPoints];
	static int[] pointLine4=new int[maxchartPoints];
	static int[] pointLine5=new int[maxchartPoints];
	static String outputDir="C:\\Users\\eric\\workspace\\GetLottery";

private class DrawData
{
public double price;
public int volDelta;
	public DrawData(double x, int y)
	{
		price=x;
		volDelta=y;
	}
	public String toString()
	{
		return "("+dataF.format(price)+", "+dataIntF.format(volDelta)+")";
	}
}

Vector<DrawData> myDrawData;
int hits;
int maxNumber;

public void init() 
{
        //Initialize drawing colors
        setBackground(bg);
        setForeground(fg);
	
}
   
	static FontMetrics pickFont(Graphics2D g2,
                         String longString,
                         int xSpace) 
	{
        	//boolean fontFits = false;
	        Font font = g2.getFont();
	        String name = font.getName();
	        int style = font.getStyle();
		g2.setFont(font = new Font(name,  style, minFontSize+20));
	        do
		{
			FontMetrics fontMetrics = g2.getFontMetrics();
	        	if ( (fontMetrics.getHeight() <= maxCharHeight)
                		 && (fontMetrics.stringWidth(longString)) <= xSpace)
			break;
			int size=g2.getFont().getSize();
			g2.setFont(font = new Font(name,  style, size-1));
        	} while (g2.getFont().getSize() > minFontSize);

	        return g2.getFontMetrics();
	}

	static int iCurrent=0;
	static int[] currentLine=null;//pointLine1;
	boolean drawSpecial;
	int[] specialData;
	Vector<int[]> samples;
	
	boolean drawGraphics(Graphics2D g2, Dimension d, Vector<int[]> dataSamples)
	{
		if (dataSamples==null || dataSamples.size()<1) return false;
	//int dmX=d.width;
	//int dmY=d.height;
		
        //Graphics2D g2 = (Graphics2D) g;
	String exS="15.6";
	 g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        //Dimension d = getSize();

        fontMetrics = pickFont(g2, exS, (int)(d.width*0.2));
	g2.setBackground(Color.white);
	int showWidth=fontMetrics.stringWidth(exS);
	int showHeight=fontMetrics.getHeight();
        //Color fg3D = Color.lightGray;

    int myChartWidth = (int)(d.width*0.95);
        //int myGridHeight = d.height/10;   //3/10 for vol, 6/10 for price  
	int myChartHeight=95*d.height/100;
	
      
	
	//readTodayData();
	
	g2.clearRect(0,0, d.width, d.height);
	Color[] useColors={Color.BLUE, Color.ORANGE, Color.MAGENTA, Color.GREEN, Color.RED};

	//totalPoints=dataSamples.get(0).length;
	maxNumber=-100000;
	int minNumber=10000;
	totalPoints=dataSamples.get(0).length;
	for (int i=0; i<dataSamples.size(); i++){
		if (totalPoints < dataSamples.get(i).length)
			totalPoints = dataSamples.get(i).length;
		for (int x=0; x<dataSamples.get(i).length; x++){
			if (maxNumber < dataSamples.get(i)[x])
				maxNumber = dataSamples.get(i)[x];
			if (minNumber > dataSamples.get(i)[x])
				minNumber = dataSamples.get(i)[x];
		}
	}
	int chart0ToMax=50;
	maxNumber=40;
	minNumber=0;
	int yRange=maxNumber - minNumber;
	int dY=d.height/(50*105/100);//(yRange*105/100);
	int dX=d.width/(totalPoints*105/100);
	
    int xPos=myChartWidth-showWidth/2-dX;
    g2.setColor(Color.black);
    g2.setStroke(dashed);//new BasicStroke(1.0f));
    	
	g2.setColor(Color.black);
	g2.setStroke(stroke);
	int yDelta=yRange/50;
	for (int i=0; i<51; i += 5)//i<yRange+1; i += yDelta)
	{
		//int yV=50*(i - minNumber)/yRange;
		if (i % 2==0)
		g2.drawString(""+(i*yDelta+minNumber), myChartWidth-showWidth/3, i*dY);
		else
			g2.drawString(""+(i*yDelta+minNumber), 0, i*dY);
		g2.draw(new Line2D.Double(myChartWidth-showWidth/2, i*dY, myChartWidth-showWidth/2+1, i*dY));
	}
        g2.draw(new Line2D.Double(0, 0, myChartWidth, 0));
        int xOffset=showWidth/2;
        xPos=myChartWidth-showWidth/2;
                
        g2.draw(new Line2D.Double(xPos, 0, xPos, myChartHeight));
       
        GeneralPath[] polylineD = new GeneralPath[dataSamples.size()];
        for (int i=0; i<dataSamples.size(); i++){
        	polylineD[i]=new GeneralPath(GeneralPath.WIND_EVEN_ODD,totalPoints); 
        	int yVal=chart0ToMax*(dataSamples.get(i)[0] - minNumber)/yRange;    		
        	polylineD[i].moveTo(xOffset, yVal*dY);
        }
                
        for (int i=0; i<totalPoints; i++)
        {
        	xPos = i*dX+xOffset;
        	if (dataSamples.get(0)[i]==0) 
        		{break;}
        	for (int j=0; j<dataSamples.size(); j++)
        	{      
        		int yVal=chart0ToMax*(dataSamples.get(j)[i] - minNumber)/yRange;
        		polylineD[j].lineTo(xPos, yVal*dY);
        		//int j=lineNumber;
        		//polylineD[j].lineTo(xPos, dataSamples.get(j)[i]*dY);
        	}
        	if (i % 5 == 0){
        		//int yVal=chart0ToMax*(maxNumber1 - minNumber)/yRange;
        		int y=xOffset;
        		if (i % 10==0) y=myChartHeight-xOffset;
        		g2.drawString(""+i, xPos, y);
        		g2.draw(new Line2D.Double(xPos, 0, xPos, myChartHeight-xOffset));
        	}
        }
        for (int i=0; i<dataSamples.size(); i++){
        	g2.setColor(useColors[i]);
        	g2.draw(polylineD[i]);
        }

        if (drawSpecial && specialData != null && specialData.length > 5){
        	GeneralPath polylineS = new GeneralPath(GeneralPath.WIND_EVEN_ODD,specialData.length); 
        	xPos=myChartWidth-showWidth/2;
        	polylineS.moveTo(xPos, specialData[0]);
        	for (int i=0; i<specialData.length; i++){
        		xPos -= dX;
        		polylineS.lineTo(xPos, (40-specialData[i])*dY);
        	}
        	g2.setColor(Color.red);
        	g2.draw(polylineS);
        }
	return true;
	}

	BufferedImage buildImgBuf(Dimension d)
	{

	//int dmX=d.width;
	//int dmY=d.height;
	//Rectangle area=new Rectangle(d);
	BufferedImage gBufImg= ImgFactory.getImg(500, 600); //new BufferedImage(dmX, dmY, BufferedImage.TYPE_INT_ARGB);
	Graphics2D g2=gBufImg.createGraphics();
	if (drawGraphics(g2, d, samples))
		return gBufImg;
		return null;

	}

    public void paint(Graphics g) {
        Graphics2D g2 = (Graphics2D) g;
        Dimension d = getSize();
	BufferedImage toDraw=buildImgBuf(d);
	if (toDraw != null) g2.drawImage(toDraw, null, 0, 0);

	g2.dispose();
	
	}

	public boolean fillImg(BufferedImage bi, int width, int height, Vector<int[]> dataSamples)
	{
	Graphics g=bi.createGraphics();
	
		Graphics2D g2 = (Graphics2D) g;
        	//BufferedImage toDraw=buildImgBuf(new Dimension(width, height));
		boolean ok=drawGraphics(g2, new Dimension(width, height), dataSamples);
		//if (toDraw == null) return false;
		g2.setBackground(Color.white);
		
		if (ok) g2.drawImage(bi, null, 0, 0);
		return ok;	
	}

synchronized boolean putImg2File(BufferedImage bi, File toFile)
{
	try {
		ImageIO.write(bi, "png", toFile);
	} catch (IOException e){return false;}
		return true;
}

void getPngFile(BufferedImage bi, int width, int height, String fileName, Vector<int[]> dataSamples)
{
	Graphics g=bi.getGraphics();

	fillImg(bi, width, height, dataSamples);
	Graphics2D g2=(Graphics2D)g;
	g2.getBackground();
        
	g2.drawImage(bi, null, 0, 0);
	
	String dFF=fileName;
	File myNew=new File(dFF+".png");
	if (putImg2File(bi, myNew) ){
		File myDup=new File(dFF+"_2.png");
		File myOld=new File(dFF+"Old.png");
		if (myOld.exists()) myOld.delete();
		if (myDup.exists() && !myOld.exists()) myDup.renameTo(myOld);
		myNew.renameTo(myDup);
	}
	return;
}
		
String forFile;
static String fileBase;
int lineNumber=0;
boolean drawMultiple;
public void drawDelta(int[] deltaData)
{
	int width=600, height=500;
	BufferedImage bi=ImgFactory.getImg(width, height); //new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
	Graphics g=bi.getGraphics();
	drawSpecial=true;
	specialData=deltaData;
	getPngFile(bi, width, height, fileBase+forFile+"Delta", samples);
	
}
public void run1() 
{
        //ShapesDemo2D Demo2D = new ShapesDemo2D();
        //f.getContentPane().add("Center", Demo2D);
        //Demo2D.init();
        int width=600, height=500;
//System.out.println("I am here");
	//readChartData();
	//f.pack();
	//Demo2D.setSize(new Dimension(width, height));
        //f.setSize(new Dimension(width, height));
        //f.setVisible(true);
	//BufferedImage bi=(BufferedImage)Demo2D.createImage(width, height);
	BufferedImage bi=ImgFactory.getImg(width, height); //new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
	Graphics g=bi.getGraphics();
	//paint(g);
	//Demo2D.paint(g);
	//int i=0;
	//if (myQuotes.size() <1) return;
	if (drawMultiple){
		getPngFile(bi, width, height, fileBase+forFile+"ALL", samples);
		return;
	}
	
	for (int i=0; i<5; i++){
		Vector<int[]> thisSample=new Vector<int[]>();
		thisSample.add(samples.get(i));
		getPngFile(bi, width, height, fileBase+forFile+"_"+i, thisSample);
	}
}

static double[] getRangePDF(int from, int to, Vector<int[]> refD){
	double[] linePdf=new double[40];
	Arrays.fill(linePdf,0);
	int iC=0;
	boolean stop=false;
	for (int i=from; i<to; i++){
		for (int s=0; s<refD.size(); s++){
			if (refD.get(s)[i]==0) {				
				stop=true;
				break;
			}
			iC++;
			linePdf[refD.get(s)[i]]++;
		}
		if (stop) break;
	}
	for (int i=0; i<40; i++){
		linePdf[i] /= (1*iC);
	}
	return linePdf;
}

static Vector<float[]> linePDF(Vector<int[]> refD){
	Vector<float[]> retV=new Vector<float[]>();
	for (int s=0; s<refD.size(); s++){
		float[] linePdf=new float[40];
		Arrays.fill(linePdf, 0);
		for (int i=0; i<refD.get(0).length; i++){
			linePdf[refD.get(s)[i]]++;
		}
		for (int i=0; i<40; i++){
			linePdf[i] /= refD.get(0).length;
		}
		retV.add(linePdf);
	}
	return retV;
}

static Vector<float[]> measureLinePDF(double[] pdf, Vector<int[]> refD){
	Vector<float[]> retV=new Vector<float[]>();
	for (int s=0; s<refD.size(); s++){
		float[] linePdf=new float[40];
		Arrays.fill(linePdf, 0);
		for (int i=0; i<refD.get(0).length; i++){
			//double v=
			linePdf[refD.get(s)[i]] += pdf[refD.get(s)[i]];
		}
		//for (int i=0; i<40; i++){
			//linePdf[i] /= refD.get(0).length;
		//}
		retV.add(linePdf);
	}
	return retV;
}

void bulkNormalization(Vector<int[]> inData){
	Vector<int[]> outResult=new Vector<int[]>();
	final int totalSample=inData.get(0).length;
	int[] iValue=new int[totalSample];
	int iSet=inData.size();
	long fMax=-9999999, fMin=999999;
	for (int i=0; i<iSet; i++){
		for (int n=1; n<totalSample; n++)
		{
			int value=inData.get(i)[n];
			if (fMax < value) fMax=value;
			if (fMin > value) fMin=value;
		}
	}
	for (int i=0; i<iSet; i++){
		for (int n=1; n<totalSample; n++)
		{
			float m=inData.get(i)[n];
				m -= fMin;
				m /= (fMax-fMin);
				m *= 38;
				inData.get(i)[n]=39-Math.round(m);
		}	
	}	
}

static Vector<int[]>  getPrimeData(Vector<int[]> inData){
	Vector<int[]> retV=new Vector<int[]>();
	final int totalSample=inData.get(0).length;
	for (int k=0; k<inData.size(); k++){
		int[] prime=new int[totalSample];
		for (int i=0; i<totalSample-1; i++){
			prime[i]=inData.get(k)[i]-inData.get(k)[i+1];
		}
		retV.add(prime);
	}
	return retV;
}

static Vector<int[]>  getAscendPrimeData(Vector<int[]> inData){
	Vector<int[]> retV=new Vector<int[]>();
	final int totalSample=inData.get(0).length;
	for (int k=0; k<inData.size(); k++){
		int[] prime=new int[totalSample];
		for (int i=0; i<totalSample-1; i++){
			prime[i]=inData.get(k)[i+1]-inData.get(k)[i];
		}
		retV.add(prime);
	}
	return retV;
}
int[] rangeBulkReplication(Vector<int[]> inData, int range){
	Vector<int[]> outResult=new Vector<int[]>();
	final int totalSample=inData.get(0).length;
	if (totalSample < range) return null;
	
	Vector<int[]> prime=getPrimeData(inData);
	int[] iValue=new int[totalSample];
	Arrays.fill(iValue, 40);
	int iSet=inData.size();
	float[] avg=new float[iSet];
	Arrays.fill(avg, 0);
	for (int i=0; i<iSet; i++){
		int[] home=Arrays.copyOf(prime.get(i), range);//inData.get(i), range);
		
		outResult.add(Arrays.copyOf(iValue, iValue.length));	
		for (int j=1; j<totalSample-range-1; j++){
			long value=0;
			for (int k=0; k<range; k++){
				value += Math.abs(prime.get(i)[j+k]-home[k]);
			}
			outResult.get(i)[j]=(int)value;
		}
	}
	outResult.add(Arrays.copyOf(iValue, iValue.length)); //additional set for calculated
	
	long fMax=-9999999, fMin=999999;
	
		for (int n=1; n<totalSample-range; n++)
		{
			long value=0;
			for (int i=0; i<iSet; i++){
				value += outResult.get(i)[n];
			}
			if (fMax < value) fMax=value;
			if (fMin > value) fMin=value;
			outResult.get(iSet)[n]=(int)value;
		}
		
		for (int n=1; n<totalSample-range; n++)
		{
			float m=outResult.get(iSet)[n];
				m -= fMin;
				m /= (fMax-fMin);
				m *= 38;
				outResult.get(iSet)[n]=39-Math.round(m);
		}	
	System.out.println("Range "+range+"; has max="+fMax+"; min="+fMin);
	return outResult.get(iSet);
}

static Vector<int[]> newProject=new Vector<int[]>();
Vector<int[]> rangeReplication(Vector<int[]> inData, int range){
	Vector<int[]> outResult=new Vector<int[]>();
	final int totalSample=inData.get(0).length;
	if (totalSample < range) return null;
	Vector<int[]> prime=prime1;//getPrimeData(inData);
	//Vector<int[]> prime2=getPrimeData(inData);
	int[] iValue=new int[totalSample];
	Arrays.fill(iValue, 40);
	int iSet=inData.size();
	float[] avg=new float[iSet];
	Arrays.fill(avg, 0);
	for (int i=0; i<iSet; i++){
		int[] home=Arrays.copyOf(prime.get(i), range);
		outResult.add(Arrays.copyOf(iValue, iValue.length));	
		long fMax=-9999999, fMin=999999;		
		for (int j=1; j<totalSample-range-1; j++){
			long value=0;
			for (int k=0; k<range; k++){
				value += Math.abs(prime.get(i)[j+k]-home[k]);
			}
			if (fMax < value) fMax=value;
			if (fMin > value) fMin=value;
			outResult.get(i)[j]=(int)value;
		}
		for (int n=1; n<totalSample-range; n++)
		{
			float m=outResult.get(i)[n];
				m -= fMin;
				m /= (fMax-fMin);
				m *= 38;
				outResult.get(i)[n]=39-Math.round(m);
		}	
	}
	
	newProject.clear();
	for (int k=0; k<5; k++){
		//System.out.print("Line "+k+" range "+range+ "has 1st/2nd deriv (");
		for (int i=0; i<range-1; i++){
			//System.out.print(","+prime1.get(k)[i]+"/"+prime2.get(k)[i]);
		} 
		int[] projects=new int[totalSample-range-1];
		int iProj=0;
		//System.out.println(")");
		for (int i=1; i<totalSample-range-1; i++){
			if (outResult.get(k)[i] > 37) {
				//System.out.print("Line "+k+", with "+outResult.get(k)[i]+" at "+i+" 1st/2nd prime(");
				for (int p=0; p<range-1; p++){
					//System.out.print(""+prime1.get(k)[i+p]+"/"+prime2.get(k)[i+p]+",");
				} 
				projects[iProj++]=inData.get(k)[0]+prime1.get(k)[i-1];
				//System.out.println(") and project:["+(inData.get(k)[0]+prime1.get(k)[i-1]));
			}
		}
		//newProject.add(Arrays.copyOf(projects, iProj));
		System.out.print("Line "+k+" range "+range+ " has projects (");
		for (int i=0; i<iProj; i++){
			System.out.print(""+projects[i]+",");
		}
		System.out.println(") ");
	}
	
	return outResult;
}

Vector<int[]> deltaAverage(Vector<int[]> inData, int range){
	Vector<int[]> outResult=new Vector<int[]>(); 
	//each line return pos delta, neg delta, abs delta
	//get delta average, delta max freq delta deviation
	final int totalSample=inData.get(0).length;
	if (totalSample < range) return null;
	int iSet=inData.size();
	float[] avg=new float[iSet];
	Arrays.fill(avg, 0);
	for (int i=0; i<iSet; i++){
		int iPos=0, iNeg=0, iAbs=0;
		long posV=0, negV=0, absV=0;
		int[] iValue=new int[range]; //to store delta
		Arrays.fill(iValue, 40);
		int[] iFreq=new int[40*2];
		Arrays.fill(iFreq, 0);
			
		long fMax=-9999999, fMin=999999;		
		for (int j=0; j<range; j++){
			iValue[j]=inData.get(i)[j]-inData.get(i)[j+1];
			iFreq[40+iValue[j]]++;
			if (iValue[j] > 0) {iPos++; posV += iValue[j]; absV += iValue[j];}
			else if (iValue[j] < 0) {iNeg++; negV += iValue[j]; absV -= iValue[j];}			
		}
		outResult.add(iFreq);
		System.out.println("Line "+i+" for range "+range+" has pos d="+posV/iPos+"; neg d="+negV/iNeg+" abs d="+absV/range);
	}
		
	return outResult;
}

Vector<int[]> movingAverage(Vector<int[]> inData, int range){
	Vector<int[]> outResult=new Vector<int[]>();
	final int totalSample=inData.get(0).length;
	if (totalSample < range) return null;
	
	int[] iValue=new int[totalSample];
	Arrays.fill(iValue, 40);
	int iSet=inData.size();
	float[] avg=new float[iSet];
	Arrays.fill(avg, 0);
	for (int i=0; i<iSet; i++){
		//int[] home=Arrays.copyOf(inData.get(i), range);
		outResult.add(Arrays.copyOf(iValue, iValue.length));	
				
		for (int j=0; j<totalSample-range; j++){
			long value=0;
			for (int k=0; k<range; k++){
				//value += (inData.get(i)[j+k]-home[k])*(inData.get(i)[j+k]-home[k]);
				value += inData.get(i)[j+k];
			}
			value /=range;
			outResult.get(i)[j]=(int)value;
		}
	}
	return outResult;
}
//measuredAutoCorrelation

static Vector<int[]> measuredRangeAutoCorrelation(Vector<int[]> inData, int range){
	Vector<int[]> outResult=new Vector<int[]>();
	int dataLength=inData.get(0).length;
	int[] iValue=new int[dataLength];
	Arrays.fill(iValue, 0);
	int iSet=inData.size();
	
	
	double[] pdf=getRangePDF(0, inData.get(0).length, inData);
	
	
	//double[] 
			measuredAvg=new double[iSet];
	Arrays.fill(measuredAvg, 0);
	for (int i=0; i<iSet; i++){
		outResult.add(Arrays.copyOf(iValue, iValue.length));
		int k=inData.get(i).length;
		for (int j=0; j<k; j++)
		{
			measuredAvg[i] += (inData.get(i)[j]*pdf[inData.get(i)[j]]);
		}
		//avg[i] /= k;		
	}
	for (int i=0; i<iSet; i++){
		outResult.add(Arrays.copyOf(iValue, dataLength-range));
		//int k=inData.get(0).length;
		float fMax=-9999999, fMin=999999;
		for (int j=1; j<dataLength-range; j++)
		{
			float value=0;
			for (int n=0; n<range; n++){
				float f1=inData.get(i)[n];
				if (n+j >= dataLength) continue;
				float f2=inData.get(i)[j+n];
			value += (f1-measuredAvg[i])*(f2-measuredAvg[i]);
			}
			if (fMax < value) fMax=value;
			if (fMin > value) fMin=value;
			outResult.get(i)[j]=Math.round(value);
		}
		if (Math.abs(fMin)>fMax){
			System.out.println("line "+i+" has inverAuto");
			fMax=Math.abs(fMin);
		}
		for (int n=1; n<dataLength-range; n++)
		{
			float m=Math.abs(outResult.get(i)[n]);
				//m -= fMin;
				m /= (fMax);//-fMin);
				m *= 38;
				outResult.get(i)[n]=Math.round(m)+1;
		}	
		outResult.get(i)[0]=0;
	}
	return outResult;
}

static Vector<int[]> getRangeAutoCorrelation(Vector<int[]> inData, int range){
	Vector<int[]> outResult=new Vector<int[]>();
	int dataLength=inData.get(0).length;
	int[] iValue=new int[dataLength];
	Arrays.fill(iValue, 0);
	int iSet=inData.size();
	float[] avg=new float[iSet];
	Arrays.fill(avg, 0);
	
	for (int i=0; i<iSet; i++){
		outResult.add(Arrays.copyOf(iValue, dataLength-range));
		//int k=inData.get(0).length;
		float fMax=-9999999, fMin=999999;
		for (int j=1; j<dataLength-range; j++)
		{
			float avg1=0;
			for (int n=0; n<range; n++)
			{
				avg1 += inData.get(i)[j+n];
			}
			avg1 /= range;	
			float value=0;
			for (int n=0; n<range; n++){
				float f1=inData.get(i)[n];
				if (n+j >= dataLength) continue;
				float f2=inData.get(i)[j+n];
			value += (f1-avg1)*(f2-avg1);
			}
			if (fMax < value) fMax=value;
			if (fMin > value) fMin=value;
			outResult.get(i)[j]=Math.round(value);
		}
		if (Math.abs(fMin)>fMax){
			System.out.println("line "+i+" has inverAuto");
			fMax=Math.abs(fMin);
		}
		for (int n=1; n<dataLength-range; n++)
		{
			float m=Math.abs(outResult.get(i)[n]);
				//m -= fMin;
				m /= (fMax);//-fMin);
				m *= 38;
				outResult.get(i)[n]=Math.round(m)+1;
		}	
		outResult.get(i)[0]=0;
	}
	return outResult;
}

int tryMeasuredAutoCorrelation(int tryAt, int[] inData){
	if (tryAt > inData.length-20) return 0;
	float[] retData=new float[40];
	int[] tryData=new int[inData.length+1];
	for (int i=0; i<inData.length; i++){
		tryData[i+1]=inData[i];
	}
	int[] iValue=new int[inData.length];
	Arrays.fill(iValue, 0);
	retData[0]=0;
	for (int p=1; p<40; p++){
		float avg=0;
		tryData[0]=p;
		int k=inData.length+1;
		for (int j=0; j<k; j++)
		{
			avg += tryData[j];
		}
		avg /= k;		
		float fMax=-9999999;
		
		for (int j=1; j<k; j++)
		{
			float value=0;
			for (int n=0; n<k; n++){
				float f1=tryData[n];
				if (n-j<0) continue;
				float f2=tryData[n-j];
			value += (f1-avg)*(f2-avg);
			}
			if (fMax < value) { fMax=value; }
		}
		retData[p]=fMax;
	}
	int maxAt=0;
	float fMax=-9999999;
	for (int i=0; i<40; i++){
		if (fMax < retData[i]) {
			fMax = retData[i];
			maxAt=i;
		}
	}
	System.out.println("found max when try "+maxAt);
		return maxAt;
}

int getTryAutoCorrelation(int tryAt, int[] inData){
	int range=inData.length-tryAt;
	if (range < 39)return -1;
	//if (inData.length-tryAt < 39*6) return 0;
	float[] retData=new float[40];
	int[] tryData=new int[inData.length+1];
	for (int i=0; i<inData.length; i++){
		tryData[i+1]=inData[i];
	}
	int[] iValue=new int[inData.length];
	Arrays.fill(iValue, 0);
	retData[0]=0;
	float avg=0;
	int k=inData.length+1;
	for (int j=0; j<k; j++)
	{
		avg += tryData[j];
	}
	avg /= k;
	if (measuredPDF==null)
		measuredPDF=getRangePDF(0, globalSample.get(0).length, globalSample);
	for (int p=1; p<40; p++){
		tryData[0]=p;				
		float fMax=-9999999;		
		float value=0;
			for (int n=tryAt; n<tryAt+range; n++){
				float f1=tryData[n];
				//if (n-tryAt<0) continue;
				float f2=tryData[n-tryAt];
				value += ((f1-avg)*(f2-avg)*measuredPDF[tryData[n]]);
			}
			if (fMax < value) { fMax=value; }
		
		retData[p]=Math.abs(fMax);
	}
	int maxAt=0;
	float fMax=-9999999;
	for (int i=0; i<40; i++){
		if (fMax < retData[i]) {
			fMax = retData[i];
			maxAt=i;
		}
	}
	System.out.println("found max when try "+maxAt);
		return maxAt;
}

static double[] noisePower;//autocorr(0)

static Vector<double[]> getAutoCorrelation(Vector<int[]> inData){
	Vector<double[]> outResult=new Vector<double[]>();
	double[] iValue=new double[inData.get(0).length];
	Arrays.fill(iValue, 0);
	int iSet=inData.size();
	float[] avg=new float[iSet];
	Arrays.fill(avg, 0);
	for (int i=0; i<iSet; i++){
		outResult.add(Arrays.copyOf(iValue, iValue.length));
		int k=inData.get(i).length;
		for (int j=0; j<k; j++)
		{
			avg[i] += inData.get(i)[j];
		}
		avg[i] /= k;		
	}
	noisePower=new double[iSet];
	for (int i=0; i<iSet; i++){
		int k=inData.get(0).length;
		float fMax=-9999999, fMin=999999;
		int maxAt=0, minAt=0;
		for (int j=0; j<k; j++)
		{
			float value=0;
			for (int n=0; n<k; n++){
				float f1=inData.get(i)[n];
				if (n-j<0) continue;
				float f2=inData.get(i)[n-j];
				value += (f1-avg[i])*(f2-avg[i]);
			}
			if (j>0) 
			{
				//if (fMax < value) { fMax=value; maxAt=j;}
				//if (fMin > value) { fMin=value; minAt=j;}
				outResult.get(i)[j]=value;//Math.round(value);
			}
			else
			noisePower[i]=value;
		}
		//System.out.println("line "+(i+1)+" has max "+fMax+" at "+maxAt+"; min "+fMin+" at "+minAt);
		//if (Math.abs(fMin) > fMax) fMax=-fMin;
		/*
		  for (int n=1; n<k; n++)
		 
		{
			float m=Math.abs(outResult.get(i)[n]);
				//m -= fMin;
				m /= (fMax);//-fMin);
				m *= 38;
				outResult.get(i)[n]=Math.round(m)+1;
		}
		*/
		outResult.get(i)[0]=0;
	}
	return outResult;
}
static double[] measuredPDF=null;
static double[] measuredAvg;
static Vector<double[]> measuredAutoCorrelation(Vector<int[]> inData){
	Vector<double[]> outResult=new Vector<double[]>();
	double[] pdf=getRangePDF(0, inData.get(0).length, inData);
	double[] iValue=new double[inData.get(0).length];
	Arrays.fill(iValue, 0);
	int iSet=inData.size();
	//double[] 
			measuredAvg=new double[iSet];
	Arrays.fill(measuredAvg, 0);
	for (int s=0; s<iSet; s++){
		outResult.add(Arrays.copyOf(iValue, iValue.length));
		int k=inData.get(s).length;
		for (int j=0; j<k; j++)
		{
			measuredAvg[s] += (inData.get(s)[j]*pdf[inData.get(s)[j]]);
		}
		//avg[i] /= k;		
	}
	noisePower=new double[iSet];
	for (int i=0; i<iSet; i++){
		int k=inData.get(0).length;
		float fMax=-9999999, fMin=999999;
		int maxAt=0, minAt=0;
		for (int j=0; j<k; j++)
		{
			float value=0;
			for (int n=0; n<k; n++){
				float f1=inData.get(i)[n];
				if (n-j<0) continue;
				float f2=inData.get(i)[n-j];
				value += ((f1-measuredAvg[i])*(f2-measuredAvg[i])*pdf[inData.get(i)[n]]);
			}
			if (j>0) 
			{
				//value=Math.abs(value);
				//if (fMax < value) { fMax=value; maxAt=j;}
				//if (fMin > value) { fMin=value; minAt=j;}
				outResult.get(i)[j]=value;//Math.round(value);
			}
			else
			noisePower[i]=value;
		}
		//System.out.println("line "+(i+1)+" has max "+fMax+" at "+maxAt+"; min "+fMin+" at "+minAt);
		//if (Math.abs(fMin) > fMax) fMax=-fMin;
		/*
		for (int n=1; n<k; n++)
		{
			float m=Math.abs(outResult.get(i)[n]);
				//m -= fMin;
				m /= (fMax);//-fMin);
				m *= 38;
				outResult.get(i)[n]=Math.round(m)+1;
		}
		*/	
		outResult.get(i)[0]=0;
	}
	return outResult;
}

static float getProject(int[] refD, int loc){
	int iLen=refD.length;
	int avgH=0;
	int avgL=0;
	float areaH=0;
	float areaL=0;
	for (int i=0; i<60; i++){
		avgH += refD[i];
		if (i+loc == refD.length) return -1;
		avgL += refD[i+loc];
	}
	avgL /= 60;
	avgH /= 60;
	for (int i=0; i<60; i++){
		areaH += Math.abs(refD[i]-avgH);
		areaL += Math.abs(refD[i+loc]-avgL);
	}
	float r=(areaL-areaH)/areaL;
	float d=(refD[loc-1]-refD[loc])*(1-r);
	return refD[0]+d;//Math.round(d);
}

Vector<int[]> putList2File(Vector<double[]> allList, String fileName, Vector<int[]> allRefD){
	BufferedWriter aWriter;
	Vector<int[]> returnV=new Vector<int[]>();
	try {
		aWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileBase+fileName+".txt")));						
	 for (int s=0; s<5; s++){
		 double[] iList=allList.get(s);
		 int[] refD=allRefD.get(s);
	int iMx1=0, iAt1=0;
	int iMx2=0, iAt2=0;
	int iMx3=0, iAt3=0;
	for (int i=1; i<iList.length; i++){
		if (iList[i]==0) break;
		if (iList[i] < 20) continue;
		
			if (iList[i] > iMx1){
				iMx1=(int)Math.round(iList[i]);
				iAt1=i;
			}
			else
				if (iList[i] > iMx2){
					iMx2=(int)Math.round(iList[i]);
					iAt2=i;
				}
				else
					if (iList[i] > iMx3){
						iMx3=(int)Math.round(iList[i]);
						iAt3=i;
					}
			//if (i % 8 == 0) aWriter.newLine();
			//aWriter.newLine();				
				
	} 
	/*
	int[] mX=new int[iList.length/3];
	int iX=0;
	Arrays.fill(mX, 0);
	int[] m2=new int[iList.length/3];
	int i2=0;
	Arrays.fill(m2, 0);
	int[] m3=new int[iList.length/3];
	int i3=0;
	Arrays.fill(m3, 0);
	for (int i=0; i<iList.length; i++){
		if (iList[i]==iMx) mX[iX++]=i;
		if (iList[i]==iMx-1) m2[i2++]=i;
		if (iList[i]==iMx-2) m3[i3++]=i;
	}
	
		aWriter.newLine();
		aWriter.write(fileName+": mx "+iMx+"; [");
		for (int i=0; i<iX; i++) {
		*/
	aWriter.write("Line "+s); 
	aWriter.newLine();
			//if (mX[i] < 2) continue;
			float r=refD[iAt1-1]-refD[iAt1];
			r /= (refD[iAt1]);
			int sign=1;//(refD[iAt1+1]-refD[iAt1])*(refD[1]-refD[0])<0?-1:1;
						
			//double r=(1.0*refD[0]-1.0*refD[1])/(1.0*refD[mX[i]]-1.0*refD[mX[i]+1]);
			aWriter.write(", @"+iAt1+" shift:"+(refD[0]+sign*(refD[iAt1-1]-refD[iAt1]))+//(dF.format(refD[0]*(1.0+r))+
					", v-ratio:"+dF.format(getProject(refD, iAt1))+", next:"+refD[iAt1-1]);
				aWriter.write("]");
				//aWriter.write("try:("+getTryAutoCorrelation(mX[i]+1, refD)+")");		
		aWriter.newLine();
		
		iAt1=iAt2;
		sign=1;//(refD[iAt1+1]-refD[iAt1])*(refD[1]-refD[0])<0?-1:1;	
		//double r=(1.0*refD[0]-1.0*refD[1])/(1.0*refD[mX[i]]-1.0*refD[mX[i]+1]);
		aWriter.write(", @"+iAt1+" shift:"+(refD[0]+sign*(refD[iAt1-1]-refD[iAt1]))+//(dF.format(refD[0]*(1.0+r))+
				", v-ratio:"+dF.format(getProject(refD, iAt1))+", next:"+refD[iAt1-1]);
			aWriter.write("]");
			//aWriter.write("try:("+getTryAutoCorrelation(mX[i]+1, refD)+")");	
	aWriter.newLine();
	
	iAt1=iAt3;
	sign=1;//(refD[iAt1+1]-refD[iAt1])*(refD[1]-refD[0])<0?-1:1;
	//double r=(1.0*refD[0]-1.0*refD[1])/(1.0*refD[mX[i]]-1.0*refD[mX[i]+1]);
	aWriter.write(", @"+iAt1+" shift:"+(refD[0]+sign*(refD[iAt1-1]-refD[iAt1]))+//(dF.format(refD[0]*(1.0+r))+
			", v-ratio:"+dF.format(getProject(refD, iAt1))+", next:"+refD[iAt1-1]);
		aWriter.write("]");
		//aWriter.write("try:("+getTryAutoCorrelation(mX[i]+1, refD)+")");
		aWriter.newLine();
/*
		aWriter.write(fileName+": m2x "+(iMx-1)+"; [");
		for (int i=0; i<i2; i++) if (m2[i] > 1) aWriter.write(", "+refD[m2[i]]+"|"+refD[m2[i]-1]);
		aWriter.write("]");
		aWriter.newLine();
		aWriter.write(fileName+": m3x "+(iMx-2)+"; [");
		for (int i=0; i<i3; i++) if (m3[i] > 1) aWriter.write(", "+refD[m3[i]]+"|"+refD[m3[i]-1]);
		aWriter.write("]");
		aWriter.newLine();
		if (iX >0)
		returnV.add(Arrays.copyOf(mX, iX));
		if (i2 >0)
		returnV.add(Arrays.copyOf(m2, i2));
		if (i3>0)
		returnV.add(Arrays.copyOf(m3, i3));
		*/
	 }
		aWriter.close();
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	return returnV;
}

static void evaluateAutoCorr(Vector<int[]> refData){
	BufferedWriter aWriter;
	int[] found_ratio=new int[6];
	Arrays.fill(found_ratio, 0);
	Vector<int[]> returnV=new Vector<int[]>();
	int[] totalFits=new int[6];
	Arrays.fill(totalFits, 0);
	try {
		aWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileBase+"testPrimeAuto"+".txt")));						
	

	int iLen=refData.get(0).length;
	while (refData.get(0)[--iLen]==0) continue;
	int[] hits=new int[5];
	int[] found=new int[40];
	for (int i=iLen-78*3; i>-1; i--)
	{
		String text="****("+i+")**********check <<";
		Vector<int[]> testData=new Vector<int[]>();
		for (int s=0; s<5; s++){
			hits[s]=refData.get(s)[i];
			text += (""+hits[s]+", ");
			testData.add(Arrays.copyOfRange(refData.get(s), i+1, 390));
		}
		text += ">>";
		Vector<double[]> rho=measuredAutoCorrelation(testData);
					//measuredRangeAutoCorrelation(testData, 78);
		//getRangeAutoCorrelation(testData, 78);
		int[] preds=new int[40];
		Arrays.fill(totalFits, 0);
		int found_count=0;
		aWriter.write(text); aWriter.newLine();
		Arrays.fill(found, 0);
		text =" found (";
		for (int s=0; s<5; s++){
			for (int ix=0; ix<rho.get(s).length; ix++){			
				if (rho.get(s)[ix]!=39) continue;
				float r=testData.get(s)[ix-1]-testData.get(s)[ix];
				r /= (testData.get(s)[ix]);
				int p=testData.get(s)[0]+testData.get(s)[ix-1]-testData.get(s)[ix];
				if (p<0) p=testData.get(s)[0]-(testData.get(s)[ix-1]-testData.get(s)[ix]); //happened when inverted autocorr
				if (p<0 || p> 39) continue;
				preds[p]++;
				
				if (p==hits[0] || p==hits[1] || p==hits[2] || p==hits[3] || p==hits[4]){
					text += (", "+p);
					found[p]++;
				}
				
			}
		}
		aWriter.write(text+")"); aWriter.newLine();
		text =" by predictions (";
		int iBet=0;
		int iBest=0;
		found_count=0;
		for (int ip=1; ip<40; ip++){
			if (preds[ip]<2) continue;
			if (found[ip] > 0)found_count++;
			text += (", "+ip+"["+preds[ip]+"],");
			if (preds[ip] > iBest){
				iBest = preds[ip];
				iBet=ip;
			}
		}
		aWriter.write(text+")"); aWriter.newLine();
		aWriter.write("-- hit ("+found_count+")----------- "+iBet+"["+iBest+"]-----"); aWriter.newLine();
		//if (i % 8 == 0) aWriter.newLine();
		if (found_count > 0)
			found_ratio[found_count]++;
	}
	String text=" found ratio ";
	for (int i=0; i<found_ratio.length; i++){
		text += (", "+i+"["+found_ratio[i]+"]");
	}
	aWriter.write(text+")");
	aWriter.newLine();
	
	aWriter.close();
} catch (IOException e) {
	// TODO Auto-generated catch block
	e.printStackTrace();
}
	
	
} 

static int[][] scanForFit(Vector<int[]> refData, int[] testData)
{
	System.out.println("Testing  (");
	for (int i=0; i<testData.length; i++){
	System.out.print(""+testData[i]+", ");
	}
	System.out.print(")");
	int length=refData.get(0).length;
	int[][] foundData=new int[5][length];	
	int[] idx=new int[5];
	Arrays.fill(idx, 0);
	int[] iMin=new int[5];
	Arrays.fill(iMin, 99);
	int[] difV=new int[length];
	difV[0]=0;
	int iGot=0;
	for (int i=1; i<length; i++){
		int iDif=0;
		for (int k=0; k<5; k++){
			iDif += Math.abs(refData.get(k)[i]-testData[k]);
		}
		difV[i]=iDif;
		int iRep=4;
		while (iRep > -1){
			if (iDif > iMin[iRep]) break;
				iRep--; 	
		}
		if (iRep < 4) {			
			for (int k=3; k>iRep; k--){
				iMin[k+1]=iMin[k];
			}
			iMin[iRep+1]=iDif;
		}
		//if (iDif < 5){
			//foundData[iDif][idx[iDif]++]=i;
		//}		
	}
	for (int i=1; i<length; i++){
		if (difV[i] > iMin[4]) continue;
		int k=4;
		while (k>-1){
			if (difV[i] == iMin[k]) break;
		    k--;
		}
		System.out.println("Found "+k+"th min "+iMin[k]+" at "+i+" (");
		for (int ix=0; ix<5; ix++){
			System.out.print(""+refData.get(ix)[i]+", ");
		}
		System.out.print(") and prediction (");
		for (int ix=0; ix<5; ix++){
			System.out.print(""+refData.get(ix)[i-1]+", ");
		}
		System.out.println(") ");
	}
	
	return foundData;
}

static double[] getCoeff(MyMatrix dMtx, int startFrom, int range, int[] refD){
	double[] retC=new double[range];
	for (int i=startFrom; i<startFrom+range; i++){
		retC[i-startFrom]=refD[i];
	}
	
	return dMtx.multiply(retC);
}

static double[] getCoeff(MyMatrix dMtx, int startFrom, int range, double[] refD){
	double[] retC=new double[range];
	System.arraycopy(refD, startFrom, retC, 0, range);
	return dMtx.multiply(retC);
}

static MyMatrix getSinValuesMatrix(int startFrom, int range){
	double[] data=new double[range*range];
	Vector<double[]> retV=new Vector<double[]>();
	double baseT=(2.0*22)/(7.0*40);
	int k=0;
	for (int x=startFrom; x<startFrom+range; x++){
		for (int i=1; i<range+1; i++){
			double rad=x*baseT*i;
			data[k++]=Math.sin(rad);
		}
		retV.add(data);
	}
	return new MyMatrix(retV);
}

//end of program
/*
The Taylor series expansion of sin(x) is

sin(x) = x - (x^3)/3! + (x^5)/5! - (x^7)/7! + ...

If we divide this by x, we can obtain a power series expansion for sin(x)/x:

sin(x)/x = 1 - (x^2)/3! + (x^4)/5! - (x^6)/7!+ ...

Integrating each term of the series gives you an infinite series 
for the integral of sin(x)/x:

∫ sin(x)/x dx = x - (x^3)/(3*3!) + (x^5)/(5*5!) - (x^7)/(7*7!) + ... + C

If we truncate this series after at least four terms 
we can obtain pretty good approximation formula 
for the antiderivative of sin(x)/x. 
The more terms are included, the more accurate the approximation will be 
since this is a convergent power series.
 We can now use this formula to estimate the area under the 
 curve y = sin(x)/x in the following example.
*/

static double sincIntegral(double x)
{
	double sincX=x;
	double term=1;
	int k=1;
	while (term > 0.00001){
		for (int j=1; j<2*(k+1); j++) term *= (x/j);
		term /=(2*k+1);
		double m=1;
		if (k % 2==1) m = (-1);
		sincX += (m*term);
		k++;
	}
	return sincX;
}

static double[] sinc40PI=new double[60];
static double myPI=Math.PI;

double getMeanRatio(double[] inData){
	int iLen=inData.length;
	
	 double meanRatio=0;
	 
	 for (int i=0; i<iLen; i++){
		 double conv=0;
		 for (int k=1; k<6+1; k++){
			 //if (i+k<1) continue;
			 if (i+k > iLen-1) break;
			 int t=i+(int)((k-1)/sqz);
			 if (t > iLen-1) break;
			 conv += sinc40PI[Math.abs(k)]*inData[i+(int)((k-1)/sqz)]*2/myPI;
		 }
		 for (int k=1; k<6+1; k++){
			 if (i- k<0) break;
			 int t=i-(int)(k/sqz);
			 if (t<0) break;
			 //if (i+k > iLen) break;
			 conv += sinc40PI[Math.abs(k)]*inData[i-(int)(k/sqz)]*2/myPI;
		 }
		 //conv /= 2.1174;
		 //newData[i]=(int)Math.round(conv);
		 //double diff=conv-sampled.get(s)[i];
		 double ratio=Math.abs(conv)/inData[i];
		 
		 meanRatio += ratio;
			 //System.out.println("orignal line "+s+" at "+i+" has "+dF.format(conv)+", sampled :"+sampled.get(s)[i]);
	 }
	 
	 meanRatio /= iLen;
	 return meanRatio;
}

static double getMeanRatio(int[] inData){
	int iLen=inData.length;
	
	 double meanRatio=0;
	 
	 for (int i=0; i<iLen; i++){
		 double conv=0;
		 for (int k=1; k<6+1; k++){
			 //if (i+k<1) continue;
			 if (i+k > iLen-1) break;
			 int t=i+(int)((k-1)/sqz);
			 if (t > iLen-1) break;
			 conv += sinc40PI[Math.abs(k)]*inData[i+(int)((k-1)/sqz)]*2/myPI;
		 }
		 for (int k=1; k<6+1; k++){
			 if (i- k<0) break;
			 int t=i-(int)(k/sqz);
			 if (t<0) break;
			 //if (i+k > iLen) break;
			 conv += sinc40PI[Math.abs(k)]*inData[i-(int)(k/sqz)]*2/myPI;
		 }
		 //conv /= 2.1174;
		 //newData[i]=(int)Math.round(conv);
		 //double diff=conv-sampled.get(s)[i];
		 double ratio=Math.abs(conv)/inData[i];
		 
		 meanRatio += ratio;
			 //System.out.println("orignal line "+s+" at "+i+" has "+dF.format(conv)+", sampled :"+sampled.get(s)[i]);
	 }
	 
	 meanRatio /= iLen;
	 return meanRatio;
}

static Vector<int[]> filterOutSample( Vector<int[]> sampled){
	int iLen=sampled.get(0).length;
	double pi=Math.PI;
	 Vector<int[]> retV=new  Vector<int[]>();
	 int[] newData=new int[iLen];
	 BufferedWriter aWriter;
	 String fileName="C:\\Users\\eric\\workspace\\GetLottery\\539\\filterLog.txt";
	 try {
			aWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName)));	

	 for (int s=0; s<5; s++){
		 String good1="orignal line fits at ";
		 int iBnd=sampled.get(s).length-1;
		 int iWas=0;
		 double meanDiff=0;
		 double meanRatio=0;
		 Arrays.fill(newData, 0);
		 for (int i=0; i<iLen; i++){
			 double conv=0;
			 for (int k=1; k<6+1; k++){
				 //if (i+k<1) continue;
				 if (i+k > iLen) break;
				 int t=i+(int)((k-1)/sqz);
				 if (t > iBnd) break;
				 conv += sinc40PI[Math.abs(k)]*sampled.get(s)[i+(int)((k-1)/sqz)]*2/pi;
			 }
			 for (int k=1; k<6+1; k++){
				 if (i- k<0) break;
				 int t=i-(int)(k/sqz);
				 if (t<0) break;
				 //if (i+k > iLen) break;
				 conv += sinc40PI[Math.abs(k)]*sampled.get(s)[i-(int)(k/sqz)]*2/pi;
			 }
			 conv /= 2.1174;
			 newData[i]=(int)Math.round(conv);
			 double diff=conv-sampled.get(s)[i];
			 double ratio=Math.abs(conv)/sampled.get(s)[i];
			 if (Math.abs(diff)>0.5){
				 aWriter.write("orignal line "+s+" at "+i+" has "+dF.format(conv)+", sampled :"+sampled.get(s)[i]);
					aWriter.newLine();
			 }
			 else
			 {
				 good1 += (""+i+"/("+(i-iWas)+"), ");
				 iWas=i;
			 }
			 meanDiff += diff;
			 meanRatio += ratio;
				 //System.out.println("orignal line "+s+" at "+i+" has "+dF.format(conv)+", sampled :"+sampled.get(s)[i]);
		 }
		 meanDiff /= iLen;
		 meanRatio /= iLen;
		 retV.add(Arrays.copyOf(newData, iLen));
		 aWriter.write("平均比 "+meanRatio+good1);aWriter.newLine();
	 }
		aWriter.close();
	}  catch (IOException e){
		return null;
	} 
	 return retV;
}

static double sqz=1;
static int checkCount=3;

static Vector<int[]> refineFound( Vector<int[]> sampled, String fname){
	int iLen=sampled.get(0).length;
	double pi=Math.PI;
	 Vector<int[]> retV=new  Vector<int[]>();
	 int[] newData=new int[40];
	 int checkFrom=36;
	 double ratio;//=getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	// ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio /= 5;
	 //double[setType][sqz][reTryPoint]
	 //double[][][] dtStart={{9, -3, -1, -1, -1}, {-4, 5, 1, 1, 1}} ;
	 double[][][] dtCenter={{{0.04, 0.06, 0, 0.06, 0.16}, {0.08, 0.04, -0.04, -0.02, -0.04 }},
			 {{0.18, 0.02, 0.02, 0, 0.02}, {-0.04, -0.06, 0, 0.02, 0.02}}
	 } ;
	 //double[][] dtEnd={{11, -1, 1, 1, 1},  {-2, 7, 3, 3, 3}};
	 double dtDelta=0.002;
	 
	 int selected=((int)sqz % 2);
	 BufferedWriter aWriter;
	 String fileName="C:\\Users\\eric\\workspace\\GetLottery\\539\\"+fname+checkCount+".txt";
	 try {
			aWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName)));	

	 for (int s=0; s<5; s++){
		 aWriter.write("****************Checking line "+s);aWriter.newLine();
		 String good1="try line "+s+" fits at ";
		 ratio=getMeanRatio(Arrays.copyOfRange(sampled.get(s), iLen-checkFrom, iLen));
		 Arrays.fill(newData, 0);
		 for (int i=0; i<35; i++){
			 newData[i]=sampled.get(s)[iLen-35+i];
		 }
		 double diff2=2000;
		 double[] diff3=new double[3];
		 diff3[2]=0;
		 diff3[1]=10;
		 diff3[0]=10;
		 int[] diffAt=new int[4];
		 //double nRatio=ratio*0.8;
		 //for (int dt=-5; dt<6; dt++)
		 double rdt=dtCenter[setType][selected][s]-10*dtDelta;
		 double bestRatio=1.2;
		 double bestDt=0;
		 rdt=-0.2;
		 boolean fixDt=false;
		 /*
		 if (setType==0 && s==3 && sqz==3){
			 fixDt=true;
			 rdt=-0.06;
		 }
		 if (setType==1 && s==2 && sqz==3){
			 fixDt=true;
			 rdt=0.00;
		 }
		 */
		 int iTry=0;
		 while (diff2>0.01)
		 { 
			 if (fixDt && iTry > 0) break;
			 if (!fixDt) rdt += dtDelta;
			 if (iTry > 20) 
				 break;
			 double nRatio=ratio*(1+rdt);
			 iTry++;
			 //System.out.println("Line "+s+" use ratio "+nRatio);
		 for (int n4=1+s; n4<36+s; n4++){
			 newData[38]=n4;
			 for (int n3=1+s; n3<36+s; n3++){
				 newData[37]=n3;
				 for (int n2=1+s; n2<36+s; n2++){
					 newData[36]=n2;
					 
		 for (int n1=1+s; n1<36+s; n1++){
			 newData[35]=n1;
			  
			 double[] diffS=new double[3];
		 for (int ix=0; ix<checkCount; ix++){
			 int i=ix+36-checkCount;
			 double conv=0;
			 for (int k=1; k<6+1; k++){
				 //if (i+k<1) continue;
				 int t=i+(int)((k-1)/sqz);
				 if (t > newData.length-1) break;
				 //if (i+k >39) break;
				 conv += sinc40PI[Math.abs(k)]*newData[i+(int)((k-1)/sqz)]*2/pi;
			 }
			 for (int k=1; k<6+1; k++){
				 if (i- k < 0) break;
				 int t=i-(int)(k/sqz);
				 if (t<0) break;
				 //if (i+k > iLen) break;
				 conv += sinc40PI[Math.abs(k)]*newData[i-(int)(k/sqz)]*2/pi;
			 }
			 conv /= nRatio;//ratio;//1.795;//2.1174;//
			 //newData[i]=(int)Math.round(conv);
			 diffS[ix]=Math.abs(conv-newData[i]);
			 //double ratio=Math.abs(conv)/sampled.get(s)[i];
		 }
		 
		 double tDiff=0;
		 for (int c=0; c<checkCount; c++)
		 {
		 	tDiff += diffS[c];
		 }
		 
		 if (tDiff<0.005){
			 aWriter.write("fit AT:("+n1+","+n2+","+n3+","+n4+") with "+diffS[0]+" and "+diffS[1]);
			 aWriter.newLine(); 
		 } 
		 if (tDiff < diff2){
			 diff2=tDiff;
			 diff3[0]=diffS[0];
			 diff3[1]=diffS[1];
			 diff3[2]=diffS[2];
			 diffAt[0]=n1;
			 diffAt[1]=n2;
			 diffAt[2]=n3;
			 diffAt[3]=n4;
			 bestRatio=nRatio;
			 bestDt=nRatio/ratio;

		 }
					 }
				 }
			 }
		 }
		 }
		 //meanDiff /= iLen;
		 //meanRatio /= iLen;
		 retV.add(Arrays.copyOf(newData, iLen));
		 good1 += "("+diffAt[0]+","+diffAt[1]+","+diffAt[2]+","+diffAt[3]+")";
		 good1 += " with diff="+dF.format(diff2);
		 good1 += " has a="+dF.format(diff3[0])+" b="+dF.format(diff3[1])+" c="+dF.format(diff3[2]);
		 aWriter.write(good1+")"+bestRatio+"; n="+bestDt);aWriter.newLine();
	 }
		aWriter.close();
	}  catch (IOException e){
		return null;
	} 
	 return retV;
}
static int[] checkBackFit( Vector<int[]> sampled, String fname){
	int iLen=sampled.get(0).length;
	double pi=Math.PI;
	 Vector<int[]> retV=new  Vector<int[]>();
	 int[] bestFitPoints=new int[5];
	 int[] newData=new int[40];
	 int checkFrom=36;
	 double ratio;//=getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	// ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio /= 5;
	 //double[setType][sqz][reTryPoint]
	 //double[][][] dtStart={{9, -3, -1, -1, -1}, {-4, 5, 1, 1, 1}} ;
	 double[][][] dtCenter={{{0.04, 0.06, 0, 0.06, 0.16}, {0.08, 0.04, -0.18, -0.06, -0.18 }},
			 {{0.18, 0.02, 0.02, 0, 0.02}, {-0.18, -0.06, 0, 0, 0.02}}
	 } ;
	 //double[][] dtEnd={{11, -1, 1, 1, 1},  {-2, 7, 3, 3, 3}};
	 double dtDelta=0.02;
	 
	 
	 int selected=((int)sqz % 2);
	 BufferedWriter aWriter;
	 String fileName="C:\\Users\\eric\\workspace\\GetLottery\\539\\"+fname+checkCount+".txt";
	  {
			//aWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName)));	

	 for (int s=0; s<5; s++){
		// aWriter.write("****************Checking line "+s);aWriter.newLine();
		 String good1="try line "+s+" fits at ";
		 ratio=getMeanRatio(Arrays.copyOfRange(sampled.get(s), iLen-checkFrom, iLen));
		 Arrays.fill(newData, 0);
		 for (int i=0; i<35; i++){
			 newData[i]=sampled.get(s)[iLen-35+i];
		 }
		 double diff2=2000;
		 double[] diff3=new double[3];
		 diff3[2]=0;
		 diff3[1]=10;
		 diff3[0]=10;
		 int[] diffAt=new int[4];
		 //double nRatio=ratio*0.8;
		 //for (int dt=-5; dt<6; dt++)
		 double rdt=dtCenter[setType][selected][s]-10*dtDelta;
		 double bestRatio=1.2;
		 double bestDt=0;
		 rdt=-0.2;
		 boolean fixDt=false;
		 if (setType==0 && s==3 && sqz==3){
			 fixDt=true;
			 rdt=-0.06;
		 }
		 if (setType==1 && s==2 && sqz==3){
			 fixDt=true;
			 rdt=0.00;
		 }
		 int iTry=0;
		 rdt=-0.02*10;
		 while (diff2>0.01)
		 { 
			 //if (fixDt && iTry > 0) break;
			 //if (!fixDt) 
			 rdt += dtDelta;
			 if (iTry > 20) 
				 break;
			 double nRatio=ratio*(1+rdt);
			 iTry++;
			 //System.out.println("Line "+s+" use ratio "+nRatio);
		 for (int n4=1+s; n4<36+s; n4++){
			 newData[38]=n4;
			 for (int n3=1+s; n3<36+s; n3++){
				 newData[37]=n3;
				 for (int n2=1+s; n2<36+s; n2++){
					 newData[36]=n2;
					 
		 for (int n1=1+s; n1<36+s; n1++){
			 newData[35]=n1;
			  
			 double[] diffS=new double[3];
		 for (int ix=0; ix<checkCount; ix++){
			 int i=ix+36-checkCount;
			 double conv=0;
			 for (int k=1; k<6+1; k++){
				 //if (i+k<1) continue;
				 int t=i+(int)((k-1)/sqz);
				 if (t > newData.length-1) break;
				 //if (i+k >39) break;
				 conv += sinc40PI[Math.abs(k)]*newData[i+(int)((k-1)/sqz)]*2/pi;
			 }
			 for (int k=1; k<6+1; k++){
				 if (i- k < 0) break;
				 int t=i-(int)(k/sqz);
				 if (t<0) break;
				 //if (i+k > iLen) break;
				 conv += sinc40PI[Math.abs(k)]*newData[i-(int)(k/sqz)]*2/pi;
			 }
			 conv /= nRatio;//ratio;//1.795;//2.1174;//
			 //newData[i]=(int)Math.round(conv);
			 diffS[ix]=Math.abs(conv-newData[i]);
			 //double ratio=Math.abs(conv)/sampled.get(s)[i];
		 }
		 
		 double tDiff=0;
		 for (int c=0; c<checkCount; c++)
		 {
		 	tDiff += diffS[c];
		 }
		 if (tDiff<0.005){
			 //aWriter.write("fit AT:("+n1+","+n2+","+n3+","+n4+") with "+diffS[0]+" and "+diffS[1]);
			 //aWriter.newLine(); 
		 } 
		 if (tDiff < diff2){
			 diff2=tDiff;
			 diff3[0]=diffS[0];
			 diff3[1]=diffS[1];
			 diff3[2]=diffS[2];
			 diffAt[0]=n1;
			 diffAt[1]=n2;
			 diffAt[2]=n3;
			 diffAt[3]=n4;
			 bestRatio=nRatio;
			 bestDt=nRatio/ratio;

		 }
					 }
				 }
			 }
		 }
		 }
		 //meanDiff /= iLen;
		 //meanRatio /= iLen;
		 retV.add(Arrays.copyOf(newData, iLen));
		 good1 += "("+diffAt[0]+","+diffAt[1]+","+diffAt[2]+","+diffAt[3]+")";
		 good1 += " with diff="+dF.format(diff2);
		 good1 += " has a="+dF.format(diff3[0])+" b="+dF.format(diff3[1])+" c="+dF.format(diff3[2]);
		 //aWriter.write(good1+")"+bestRatio+"; n="+bestDt);aWriter.newLine();
		 bestFitPoints[s]=diffAt[0];
	 }
		//aWriter.close();
	} 
	 return bestFitPoints;//retV;
}

static double[] expandSeries(int byFactor, double[] newData)
{
	int iLen=newData.length;
	 while (newData[iLen-1]< 0.05) iLen--;
	//double pi=Math.PI;
	 double[] retV=new  double[iLen];
	 
		 double[] newSet=new double[(iLen-1)*byFactor+1];
		 Arrays.fill(newSet, 0);
		 int iC=0;
		 for (int i=0; i<iLen-1; i++){
			 
			 double delta = (newData[i+1]-newData[i]);
			 delta /= byFactor;
			 for (int x=0; x<byFactor; x++){
				 newSet[i*byFactor+x]=newData[i]+x*delta;
				 iC++;
			 }
			 
		 }
		 newSet[iC]=newData[iLen-1];
			 
	 return Arrays.copyOf(newSet, iC+1);
}


static Vector<double[]> expandSeries(int byFactor, Vector<int[]> orgData)
{
	
	//double pi=Math.PI;
	 Vector<double[]> retV=new  Vector<double[]>();
	 for (int s=0; s<orgData.size(); s++){
		 int iLen=orgData.get(s).length;
		 double[] newSet=new double[(iLen-1)*byFactor+1];
		 Arrays.fill(newSet, 0);
		 int iC=0;
		 for (int i=0; i<orgData.get(s).length-1; i++){
			 
			 double delta = (orgData.get(s)[i+1]-orgData.get(s)[i]);
			 delta /= byFactor;
			 for (int x=0; x<byFactor; x++){
				 newSet[i*byFactor+x]=orgData.get(s)[i]+x*delta;
				 iC++;
			 }
			 
		 }
		 newSet[iC]=orgData.get(s)[iLen-1];
		 retV.add(newSet);
	 }
	 
	 return retV;
}
int[] tryExpanedSample(int byFactor, Vector<int[]> oldSample, String fname){
	Vector<double[]> sampled=expandSeries(byFactor,oldSample);
	int iLen=sampled.get(0).length;
	double pi=Math.PI;
	 Vector<int[]> retV=new  Vector<int[]>();
	 int[] bestFitPoints=new int[5];
	 int orgCheckLen=36;
	  int checkLen=orgCheckLen*byFactor;
	 double ratio;//=getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	// ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio /= 5;
	 //double[setType][sqz][reTryPoint]
	 //double[][][] dtStart={{9, -3, -1, -1, -1}, {-4, 5, 1, 1, 1}} ;
	 double[][][] dtCenter={{{0.04, 0.06, 0, 0.06, 0.16}, {0.08, 0.04, -0.18, -0.06, -0.18 }},
			 {{0.18, 0.02, 0.02, 0, 0.02}, {-0.18, -0.06, 0, 0, 0.02}}
	 } ;
	 //double[][] dtEnd={{11, -1, 1, 1, 1},  {-2, 7, 3, 3, 3}};
	 double dtDelta=0.01;
	 	 
	 int selected=((int)sqz % 2);
	 //BufferedWriter aWriter;
	 //String fileName="for"+JackPotReader.drawDate+fname+checkCount+".txt";
	 //try {
			//aWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName)));	

	 for (int s=0; s<5; s++){
		 //aWriter.write("****************Checking line "+s);aWriter.newLine();
		 String good1="try line "+s+" fits at ";
		 ratio=getMeanRatio(Arrays.copyOfRange(sampled.get(s), iLen-checkLen, iLen));
		 double[] newData=new double[checkLen+4*byFactor];
			Arrays.fill(newData, 0);
		 for (int i=0; i<checkLen; i++){
			 newData[i]=sampled.get(s)[iLen-checkLen+i];
		 }
		 double diff2=200000;
		 double[] diff3=new double[3];
		 diff3[2]=0;
		 diff3[1]=10;
		 diff3[0]=10;
		 int[] diffAt=new int[4];
		 //double nRatio=ratio*0.8;
		 //for (int dt=-5; dt<6; dt++)
		 double rdt=dtCenter[setType][selected][s]-10*dtDelta;
		 double bestRatio=1.2;
		 double bestDt=0;
		 rdt=-0.2;
		 
		 int iTry=0;
		 //rdt=-0.02*10;
		 while (diff2>0.01)
		 { 
			 
			 rdt += dtDelta;
			 if (iTry > 40) 
				 break;
			 double nRatio=ratio*(1+rdt);
			 iTry++;
			 //System.out.println("Line "+s+" use ratio "+nRatio);
		 for (int n4=1+s; n4<36+s; n4++){
			 //newData[38]=n4;
			 //newData[38*byFactor]=n4;
			 double delta=(20 -n4)/byFactor;
			 for (int p=0; p<byFactor; p++){
				  newData[38*byFactor+p]=n4+p*delta;
			  }
			 for (int n3=1+s; n3<36+s; n3++){
				 //newData[37]=n3;
				 //newData[37*byFactor]=n3;
				 delta=(n4-n3)/byFactor;
				 for (int p=0; p<byFactor; p++){
					  newData[37*byFactor+p]=n3+p*delta;
				  }
				 for (int n2=1+s; n2<36+s; n2++){
					 //newData[36*byFactor]=n2;
					 delta=(n3-n2)/byFactor;
					 for (int p=0; p<byFactor; p++){
						  newData[36*byFactor+p]=n2+p*delta;
					  }
					 
		 for (int n1=1+s; n1<36+s; n1++){
			 //newData[35*byFactor]=n1;
			 delta=(n2-n1)/byFactor;
			 for (int p=0; p<byFactor; p++){
				  newData[35*byFactor+p]=n1+p*delta;
			  }
			 delta=(n1-newData[34*byFactor])/byFactor;
			  for (int p=1; p<byFactor; p++){
				  newData[33*byFactor+p]=newData[34*byFactor]+p*delta;
			  }
			 double[] diffS=new double[3];
		 for (int ix=0; ix<checkCount; ix++){
			 int i=ix+36-checkCount;
			 int pos=i*byFactor;
			 double conv=0;
			 int chkBnd=3*byFactor;
			 for (int k=1; k<chkBnd+1; k++){
				 //if (i+k<1) continue;
				 int t=pos+(int)((k-1)/sqz);
				 if (t > newData.length-1) break;
				 //if (i+k >39) break;
				 conv += sinc40PI[Math.abs(k)]*newData[pos+(int)((k-1)/sqz)]*2/pi;
			 }
			 for (int k=1; k<chkBnd+1; k++){
				 if (pos - k < 0) break;
				 int t=pos-(int)(k/sqz);
				 if (t<0) break;
				 //if (i+k > iLen) break;
				 conv += sinc40PI[Math.abs(k)]*newData[pos-(int)(k/sqz)]*2/pi;
			 }
			 conv /= nRatio;//ratio;//1.795;//2.1174;//
			 //newData[i]=(int)Math.round(conv);
			 diffS[ix]=Math.abs(conv-newData[pos]);
			 //double ratio=Math.abs(conv)/sampled.get(s)[i];
		 }
		 
		 double tDiff=0;
		 for (int c=0; c<checkCount; c++)
		 {
		 	tDiff += diffS[c];
		 }
		 if (tDiff<0.005){
			 //aWriter.write("fit AT:("+n1+","+n2+","+n3+","+n4+") with "+diffS[0]+" and "+diffS[1]);
			 //aWriter.newLine(); 
		 } 
		 if (tDiff < diff2){
			 diff2=tDiff;
			 diff3[0]=diffS[0];
			 diff3[1]=diffS[1];
			 diff3[2]=diffS[2];
			 diffAt[0]=n1;
			 diffAt[1]=n2;
			 diffAt[2]=n3;
			 diffAt[3]=n4;
			 bestRatio=nRatio;
			 bestDt=nRatio/ratio;

		 }
					 }
				 }
			 }
		 }
		 }
		 
		 //good1 += "("+diffAt[0]+","+diffAt[1]+","+diffAt[2]+","+diffAt[3]+")";
		 //good1 += " with diff="+dF.format(diff2);
		 //good1 += " has a="+dF.format(diff3[0])+" b="+dF.format(diff3[1])+" c="+dF.format(diff3[2]);
		 //aWriter.write(good1+")"+bestRatio+"; n="+bestDt);aWriter.newLine();
		 bestFitPoints[s]=diffAt[0];
	 }
		//aWriter.close();
	//} 
	 return bestFitPoints;//retV;
}

static double getSincConvolution(int n, int range, double[] newData){
	//f(x)*g(n-x)
	// g is sinc
	double v=0;
	for (int i=0; i<range; i++){
		if (n+i >= newData.length) break;
		v += newData[n+i]*sinc40PI[i+1];
	}
	for (int i=1; i<range; i++){
		if (n-i<0) break;
		if (n-i>=newData.length) continue;
		v += newData[n-i]*sinc40PI[i];
	}
	return v;
	//mx+b
	//m=(f[n+1]-f[n])
	//b=(n+1)*f(n)-n*f(n+1)
	/*
	int uBnd=newData.length-1;
	if (n > uBnd) return 0;
	double retV=0;
	double forward=0;
	*/
	/*
	for (int i=0; i<range; i++){
		if (n+i>uBnd || i > 53) break;
		forward += newData[n+i]*sinc40PI[i+1];
	}
	*/
	/*
	forward += newData[n]*sinc40PI[1];
	for (int i=1; i<range; i++){
		if (n-i<0 || i > 54) break;
		forward += newData[n-i]*sinc40PI[i];
	}
	return forward;
	*/
}

double getHalfSincConvolution(int n, int range, double[] newData){
	
	//mx+b
	//m=(f[n+1]-f[n])
	//b=(n+1)*f(n)-n*f(n+1)
	int uBnd=newData.length-1;
	if (n > uBnd) return 0;
	double retV=0;
	double forward=0;
	/*
	for (int i=0; i<range; i++){
		if (n+i>uBnd || i > 53) break;
		forward += newData[n+i]*sinc40PI[i+1];
	}
	*/
	forward += newData[n]*sinc40PI[1];
	for (int i=1; i<range; i++){
		if (n-i<0 || i > 54) break;
		forward += newData[n-i]*sinc40PI[i];
	}
	return forward;
}

double triangleBySinc(int n, int range, double[] newData){
	//mx+b
	//m=(f[n+1]-f[n])
	//b=(n+1)*f(n)-n*f(n+1)
	int uBnd=newData.length-1;
	if (n > uBnd) return 0;
	double retV=0;
	double forward=0;
	for (int i=0; i<range; i++){
		if (n+i>uBnd || i > 38) break;
		forward += newData[n+i]*sinc40PI[i+1];
	}
	for (int i=1; i<range; i++){
		if (n-i<0 || i > 39) break;
		forward += newData[n-i]*sinc40PI[i];
	}
	return forward;
}
int fineTuneTrianglePrediction(int s, int[] oldSample, double variableRatio, int expandFactor, int sincRange, int pWas, double vWas){
	int iLen=oldSample.length;
	int checkLen=35;
		 double[] newData=new double[40];
			Arrays.fill(newData, 0);
		 for (int i=0; i<checkLen; i++){
			 newData[i]=oldSample[iLen-checkLen+i];
		 }
		 double diff2=200000;
		 double[] diff3=new double[3];
		 diff3[2]=0;
		 diff3[1]=10;
		 diff3[0]=10;
		 int[] diffAt=new int[4];
		 //double nRatio=ratio*0.8;
		 //for (int dt=-5; dt<6; dt++)
		 double bestRatio=1.2;
		 //double bestDt=0;
		// rdt=-0.2;
		 double delta=variableRatio/100;
		 int iTry=0;
		 //rdt=-0.02*10;
		 //int expandFactor=1;
		 //int sincRange=expandFactor*2;
		 int bestFactor=0;
		 int bestRange=0;
		 double rdt=variableRatio-10*delta;
		 
		 while (diff2>0.01)
		 { 
			 
			 sincRange=expandFactor*2;
			 
			// rdt += dtDelta;
			 if (iTry > 20) 
				 break;
			// double nRatio=ratio*(1+rdt);
			 iTry++;
			 //System.out.println("Line "+s+" use ratio "+nRatio);
		 for (int n4=1+s; n4<36+s; n4 += 36){//++){
			 newData[38]=20;//n4;			 
			 for (int n3=1+s; n3<36+s; n3++){
				 newData[37]=n3;				 
				 for (int n2=1+s; n2<36+s; n2++){
					 newData[36]=n2;					 
					 for (int n1=1+s; n1<36+s; n1++){
						 newData[35]=n1;
			 
			 double[] testData=expandSeries(expandFactor,newData); 
			 double adj=rdt+delta*iTry;
			 /*
			 int iCC=0;
			 for (int v=testData.length/16; v<testData.length*15/16; v++){
				 double tmp=triangleBySinc(v, sincRange, testData);
				 adj += (tmp/testData[v]);
				 iCC++;
			 }
			 adj /= iCC;
			 //adj *= 2;*/
			 double[] diffS=new double[checkCount];
			 for (int ix=0; ix<checkCount; ix++){
				 int i=ix+36-checkCount;
				 int pos=i*expandFactor;
				 double conv=0;
				 
				 conv =triangleBySinc(pos, sincRange, testData)/adj;
				 //newData[i]=(int)Math.round(conv);
				 diffS[ix]=Math.abs(conv-testData[pos]);
				 //double ratio=Math.abs(conv)/sampled.get(s)[i];
			 }
		 
		 double tDiff=0;
		 for (int c=0; c<checkCount; c++)
		 {
		 	tDiff += diffS[c];
		 }
		 
		 if (tDiff < diff2){
			 diff2=tDiff;
			 diff3[0]=diffS[0];
			 diff3[1]=diffS[1];
			 diff3[2]=diffS[2];
			 diffAt[0]=(int)Math.round(n1);
			 diffAt[1]=(int)Math.round(n2);;
			 //diffAt[2]=n3;
			 //diffAt[3]=n4;
			 bestRatio=adj;
			 //bestDt=nRatio/ratio;
			 bestFactor=expandFactor;
			 bestRange=sincRange;

		 }
					 }
				}
			 }
		 }
				 //aWriter.write
				 //(good1+")"+bestRatio+"; n="+bestDt);aWriter.newLine();
				 //System.out.println
				 //("Line "+s+" f="+expandFactor+" diff="
						 		//+dF.format(diff2)+" bf="+bestFactor+" range="+bestRange+ " r="+dF.format(bestRatio));	 
				 //System.out.println
				// ("fine tune diff="
						 		//+dF.format(diff2)+" bf="+bestFactor+" range="+bestRange+ " r="+dF.format(bestRatio));	 
				  
		 }
		 //if (diff2 >)
		 //good1 += "("+diffAt[0]+","+diffAt[1]+","+diffAt[2]+","+diffAt[3]+")";
		 //good1 += " with diff="+dF.format(diff2);
		 //good1 += " has a="+dF.format(diff3[0])+" b="+dF.format(diff3[1])+" c="+dF.format(diff3[2]);
		 //aWriter.write
		 //(good1+")"+bestRatio+"; n="+bestDt);aWriter.newLine();
		 //System.out.println
		 //("!!!!Line "+s+" Best fit with diff="
				 		//+dF.format(diff2)+" factor="+bestFactor+" range="+bestRange);
		 //aWriter.newLine();
		 if (diff2 > vWas) return pWas;
	 return diffAt[0];//retV;
}

int fineTuneHalfPrediction(int s, int[] oldSample, double variableRatio, int expandFactor, int sincRange, int pWas, double vWas){
	int iLen=oldSample.length;
	int checkLen=35;
		 double[] newData=new double[checkLen+1];
			Arrays.fill(newData, 0);
		 for (int i=0; i<=checkLen-1; i++){
			 newData[i]=oldSample[iLen-checkLen+i];
		 }
		 double diff2=200000;
		 double[] diff3=new double[3];
		 diff3[2]=0;
		 diff3[1]=10;
		 diff3[0]=10;
		 int[] diffAt=new int[4];
		 //double nRatio=ratio*0.8;
		 //for (int dt=-5; dt<6; dt++)
		 double bestRatio=1.2;
		 //double bestDt=0;
		// rdt=-0.2;
		 double delta=variableRatio/100;
		 int iTry=0;
		 //rdt=-0.02*10;
		 //int expandFactor=1;
		 //int sincRange=expandFactor*2;
		 int bestFactor=0;
		 int bestRange=0;
		 double rdt=variableRatio-10*delta;
		 
		 while (diff2>0.01)
		 { 
			 
			 sincRange=54;//expandFactor*2;
			 
			// rdt += dtDelta;
			 if (iTry > 20) 
				 break;
			// double nRatio=ratio*(1+rdt);
			 iTry++;
			 //System.out.println("Line "+s+" use ratio "+nRatio);
		 //for (int n4=1+s; n4<36+s; n4 += 36){//++){
			 //newData[38]=20;//n4;			 
			// for (int n3=1+s; n3<36+s; n3++){
				 //newData[37]=n3;				 
				 //for (int n2=1+s; n2<36+s; n2++){
					 //newData[36]=n2;					 
					 for (int n1=1+s; n1<36+s; n1++){
						 newData[35]=n1;
			 
			 double[] testData=expandSeries(expandFactor,newData); 
			 double adj=rdt+delta*iTry;
			 /*
			 int iCC=0;
			 for (int v=testData.length/16; v<testData.length*15/16; v++){
				 double tmp=triangleBySinc(v, sincRange, testData);
				 adj += (tmp/testData[v]);
				 iCC++;
			 }
			 adj /= iCC;
			 //adj *= 2;*/
			 double[] diffS=new double[checkCount];
			 for (int ix=0; ix<checkCount; ix++){
				 int i=ix+36-checkCount;
				 int pos=i*expandFactor;
				 double conv=0;
				 
				 conv =getHalfSincConvolution(pos, sincRange, testData)/adj;
				 //newData[i]=(int)Math.round(conv);
				 diffS[ix]=Math.abs(conv-testData[pos]);
				 //double ratio=Math.abs(conv)/sampled.get(s)[i];
			 }
		 
		 double tDiff=0;
		 for (int c=0; c<checkCount; c++)
		 {
		 	tDiff += diffS[c];
		 }
		 
		 if (tDiff < diff2){
			 diff2=tDiff;
			 diff3[0]=diffS[0];
			 diff3[1]=diffS[1];
			 diff3[2]=diffS[2];
			 diffAt[0]=(int)Math.round(n1);
			 //diffAt[1]=(int)Math.round(n2);;
			 //diffAt[2]=n3;
			 //diffAt[3]=n4;
			 bestRatio=adj;
			 //bestDt=nRatio/ratio;
			 bestFactor=expandFactor;
			 bestRange=sincRange;

		 }
					 //}
				//}
			 //}
		 }
				 //aWriter.write
				 //(good1+")"+bestRatio+"; n="+bestDt);aWriter.newLine();
				 //System.out.println
				 //("Line "+s+" f="+expandFactor+" diff="
						 		//+dF.format(diff2)+" bf="+bestFactor+" range="+bestRange+ " r="+dF.format(bestRatio));	 
				 //System.out.println
				// ("fine tune diff="
						 		//+dF.format(diff2)+" bf="+bestFactor+" range="+bestRange+ " r="+dF.format(bestRatio));	 
				  
		 }
		 //if (diff2 >)
		 //good1 += "("+diffAt[0]+","+diffAt[1]+","+diffAt[2]+","+diffAt[3]+")";
		 //good1 += " with diff="+dF.format(diff2);
		 //good1 += " has a="+dF.format(diff3[0])+" b="+dF.format(diff3[1])+" c="+dF.format(diff3[2]);
		 //aWriter.write
		 //(good1+")"+bestRatio+"; n="+bestDt);aWriter.newLine();
		 //System.out.println
		 //("!!!!Line "+s+" Best fit with diff="
				 		//+dF.format(diff2)+" factor="+bestFactor+" range="+bestRange);
		 //aWriter.newLine();
		 if (diff2 > vWas) return pWas;
	 return diffAt[0];//retV;
}

int expandedBy;
int useSincRange;
int checkPositionStart;

double getMeanError(int from, int to, double[] testList, double withAdjust){
	//testList[testList.length-1]=lastV;
	double[] testData=expandSeries(expandedBy,testList); 
	double tDiff=0;
	for (int i=from; i<to; i++){
		 
		 int pos=i*expandedBy;
		 double expect=	getHalfSincConvolution(pos, useSincRange, testData)*withAdjust;			 
		 tDiff += Math.abs(testList[i] - expect);
	 }
	return tDiff/(to- from);//testList.length;
}

double getDistance(double adjust, double[] testList){
	//testList[testList.length-1]=lastV;
	double[] testData=expandSeries(expandedBy,testList); 
	double tDiff=0;
	for (int ix=0; ix<checkCount; ix++){
		 int i=ix+1+checkPositionStart-checkCount;
		 int pos=i*expandedBy;
		 				 
		 tDiff += Math.abs(testList[i] - getHalfSincConvolution(pos, useSincRange, testData)/adjust);
	 }
	return tDiff;
}

double getDiff(double adjust, double[] testList){
	//testList[testList.length-1]=lastV;
	double[] testData=expandSeries(expandedBy,testList); 
	double tDiff=0;
	for (int ix=0; ix<checkCount; ix++){
		 int i=ix+1+checkPositionStart-checkCount;
		 int pos=i*expandedBy;
		 				 
		 tDiff += (testList[i] - getHalfSincConvolution(pos, useSincRange, testData)/adjust);
	 }
	return tDiff;
}

double getDistance(double lastV, double adjust, double[] testList){
	testList[testList.length-1]=lastV;
	double[] testData=expandSeries(expandedBy,testList); 
	double tDiff=0;
	for (int ix=0; ix<checkCount; ix++){
		 int i=ix+1+checkPositionStart-checkCount;
		 int pos=i*expandedBy;
		 				 
		 tDiff += Math.abs(testList[i] - getHalfSincConvolution(pos, useSincRange, testData)/adjust);
	 }
	return tDiff;
}

double getDiff(double lastV, double adjust, double[] testList){
	testList[testList.length-1]=lastV;
	double[] testData=expandSeries(expandedBy,testList); 
	double tDiff=0;
	for (int ix=0; ix<checkCount; ix++){
		 int i=ix+1+checkPositionStart-checkCount;
		 int pos=i*expandedBy;
		 				 
		 tDiff += (testList[i] - getHalfSincConvolution(pos, useSincRange, testData)/adjust);
	 }
	return tDiff;
}

double getSolution(double[] newData, int variablePos, double guessV, double pUBND, double pLBND, double adj){
	
			double lastP=(pUBND+pLBND)/2;
			newData[variablePos]=lastP;
	double lastV=getDiff(adj, newData);
	newData[variablePos]=guessV;
	double nuP=guessV;
	double nuV=getDiff(adj, newData);
	
	double delta=100;
	int iBsect=0;
	while (Math.abs(nuV) >0.01 && delta > 0.05 && iBsect < 6)// && expandFactor<13)
	 { 
	 double tmpP=(nuP*lastV - nuV*lastP)/(lastV - nuV);
	 if  (tmpP < pUBND && tmpP > pLBND) iBsect=0;
	 else
	 {
		 iBsect++;
		 if (tmpP > pUBND) {
			 if (nuV > lastV) tmpP=(pUBND+lastP)/2;
			 else tmpP=(pUBND+nuP)/2;
		 }
		 else {
			 if (nuV > lastV) tmpP=(pLBND+lastP)/2;
			 else tmpP=(pLBND+nuP)/2;
		 }	
	 }
	 lastV=nuV;
	 lastP=nuP;
	 nuP=tmpP;
	 
	 delta=Math.abs(nuP-lastP);
	 newData[variablePos]=nuP;	
	 nuV=getDiff(adj, newData);
	 //diffAt[0]=(int)Math.round(nuP);
	 //diff2=Math.abs(nuV);
	 }
	return nuV;
}

public static double[] getSineCurveCoeff(double[] timeLine, int offSet){
	
	double predV=0;
	
	double pI=Math.PI;//*2;
	int n=timeLine.length;
	
	//boolean[] bFound=new boolean[575757];
	//Arrays.fill(bFound, false);
	double[] retV=new double[2];
	
			//double offSet=45;
			Vector<double[]> mSin=new Vector<double[]>();
			//double[] values=new double[n];
			for (int x=0; x<n; x++){				
				double[] vSin=new double[n];
				for (int v=0; v<n; v++){
					vSin[v]=Math.sin(offSet+x*pI/(v+1));
				}
				mSin.add(vSin);
			}
			MyMatrix mFit=new MyMatrix(mSin);
			MyMatrix iv=MyMatrix.inverseLU(mFit);
			if (iv==null) return null;
			
			double[] pCoeff=iv.multiply(timeLine);
			double[] checkBack=mFit.multiply(pCoeff);
			for (int ik=0; ik<n; ik++){
				if (Math.abs(checkBack[ik] - timeLine[ik]) > 0.01){
					System.out.println("try "+n+" found invalid inverse matrix for element "+ik+" mismatch:"+dF.format(checkBack[ik])+" != "+dF.format(timeLine[ik]));
					return null;
				}
			}
			return pCoeff;

}

static double getFittingByMinError(double[] inData, int chkCount){
	double outResult;
	//double[] pdf=getRangePDF(0, inData.get(0).length, inData);
	//int iSet=inData.size();
	//if (measuredAvg==null || measuredAvg.length < inData.size()){
	
		//double[] iValue=new double[inData.get(0).length];
		//Arrays.fill(iValue, 0);		
		double measuredAvg=0;
		//Arrays.fill(measuredAvg, 0);
		//for (int s=0; s<iSet; s++){
			//outResult.add(Arrays.copyOf(iValue, iValue.length));
			int k=inData.length;
			for (int j=0; j<k; j++)
			{
				//measuredAvg[s] += (inData.get(s)[j]*measuredPDF[inData.get(s)[j]]);
				measuredAvg += (inData[j]);//*measuredPDF[inData.get(s)[j]]);
			}
			measuredAvg /= k;		
		//}
	//}
	
	int iLen=inData.length;
	
	//for (int s=0; s<iSet; s++){
		//int k=39*7;//390;//
		
		//float fMax=-9999999, fMin=999999;
		//int maxAt=0, minAt=0;
		double[] fValue=new double[iLen];
		Arrays.fill(fValue, 0);
		double[] checkCurve=new double[chkCount];
		Arrays.fill(checkCurve, 0);
		
		Vector<double[]> tempBuffer=new Vector<double[]>();
		double minCaseValue=10000000;		
		int minWhen=0;
		double pI=Math.PI;
		//for (int  rd=0; rd < 27; rd ++){
			int offSet = 45;//5+rd*5;
			double minValue=10000000;
			for (int j=0; j<chkCount; j++)
			{
				checkCurve[j]=inData[iLen-chkCount+j]-measuredAvg;
			}
		double[] coeffs=getSineCurveCoeff(checkCurve, offSet);
		/* use
		 * for (int x=0; x<n; x++){ 
		 * for (int v=0; v<n; v++){
					vSin[v]=Math.sin(offSet+x*pI/(v+1));
				}
		 */
		int minAt=-1;
		for (int j=chkCount; j < iLen-1; j++)//iLen-2; j>=chkCount; j--)
		{			
			double errV=0;			
			for (int x=0; x<chkCount; x++){
				checkCurve[x]=inData[j-chkCount+x+1]-measuredAvg;			
				double r=0;
				for (int v=0; v<chkCount; v++){
					r += coeffs[v]*Math.sin(offSet+x*pI/(v+1));
				}
				errV += Math.abs(r-checkCurve[x]);
			}
			fValue[j]=errV;	
			if (errV < minValue) {
				minValue=errV;	
				minAt=j;
			}
		}
		
		outResult=inData[minAt+1];
		//}
			
	return outResult;
}

static void initGuessByAutocorrelation(double[] seq){
	for (int i=seq.length-2; i<seq.length; i++){
		seq[i]=getFittingByMinError(Arrays.copyOf(seq, i), 6);
	}
}
double[] merit_of_solution;
int[] tryHalfSincFilter(Vector<int[]> oldSample, int expandFactor, int chkCount){
	//int byFactor=32;
	//Vector<double[]> sampled=oldSample;//expandSeries(byFactor,oldSample);
	//int iLen=sampled.get(0).length;
	//double pi=Math.PI;
	 //Vector<int[]> retV=new  Vector<int[]>();
	 int[] bestFitPoints=new int[5];
	 merit_of_solution=new double[5];
	 int orgCheckCount=checkCount;
	// int orgCheckLen=36;
	  int checkLen=60;
	  //int expandFactor=expandedBy;//54/checkCount;
	  expandedBy=expandFactor;
		 int sincRange=54;//expandFactor*2;
		 useSincRange=54;
		 
	 for (int s=0; s<5; s++){
		 //aWriter.write("****************Checking line "+s);aWriter.newLine();
		 //String good1="try line "+s+" fits at ";
		 //ratio=getMeanRatio(Arrays.copyOfRange(sampled.get(s), iLen-checkLen, iLen));
		 int iLen=oldSample.get(s).length;
		 //?????????????????????????????????????????????????????????
		 double[] refData=new double[checkLen];//+2];
			Arrays.fill(refData, 0);
			double m=0;
		 for (int i=0; i<checkLen; i++){
			 refData[i]=oldSample.get(s)[iLen-checkLen+i];
			 m += refData[i];
		 }
		 m /= checkLen;
		 //?????????????????????????????????????????????????????????
		 //newData[checkLen]=m;
		 //newData[checkLen+1]=m;
		 double[] testData=expandSeries(expandFactor,refData); 
		 checkPositionStart=checkLen;
		 checkCount=chkCount;
		 //??????????????????????????????????????????????????????
		 checkCount=1;
		 double adj=0;
		 int iCC=0;
		 for (int v=(checkLen-checkCount); v<checkLen; v++){			 
			 int pos=v*expandFactor;
			 double tmp=getHalfSincConvolution(pos, sincRange, testData);
			 adj += Math.abs(tmp/refData[v]);
			 iCC++;
		 }
		 adj /=iCC;
		 double errorRef=getMeanError(0, checkCount, Arrays.copyOfRange(refData, checkLen-checkCount, checkLen), adj);
		 
		 double[] newData=Arrays.copyOf(refData, checkLen+2);//+2];	
		 
		 newData[checkLen+1]=m;
		 double diff2=200000;
		 double pLBND=s+1;
		 double pUBND=s+36;
		 
		 //newData[checkLen]=newData[checkLen-1];
		 initGuessByAutocorrelation(newData);
		 adj=0;
		 iCC=0;
		 for (int v=(checkLen-checkCount)+1; v<checkLen+1; v++){			 
			 int pos=v*expandFactor;
			 double tmp=getHalfSincConvolution(pos, sincRange, newData);
			 adj += Math.abs(tmp/newData[v]);
			 iCC++;
		 }
		 adj /=iCC;
		 double v1=getSolution(newData, checkLen, newData[checkLen], //(s+36)/4, 
				 									pUBND, pLBND, adj);
		 double sol1=newData[checkLen];
		 bestFitPoints[s]=(int)Math.round(sol1);
		 //double v=getMeanError(0, checkCount, Arrays.copyOfRange(newData, checkLen-checkCount+1, checkLen+1), adj);		 
		 //merit_of_solution[s]=(1-v/errorRef);
		 //checkCount=chkCount;
		 //continue;
		 double[] newData1=Arrays.copyOf(refData, checkLen+4);//+2];	
		 initGuessByAutocorrelation(newData1);
		 
		 double v2=getSolution(newData1, checkLen, newData[checkLen],//(s+36)*3/4, 
				 									pUBND, pLBND, adj);
		 double sol2=newData1[checkLen];
		 if (Math.abs(sol1-sol2)>1)
		 {
			 System.out.println("Found diff solutions!!!"+sol1+"("+v1+"),  and "+sol2+"("+v2+")");
		 }
		 else
		 {
			 if (Math.abs(v1) < Math.abs(v2)) sol1=sol2;
			 bestFitPoints[s]=(int)Math.round(sol1);
			 checkCount=chkCount;
			 continue;
		 }
		 double[] diff3=new double[checkCount];
		 //diff3[2]=0;
		 //diff3[1]=10;
		 //diff3[0]=10;
		 int[] diffAt=new int[4];
		 Arrays.fill(diffAt, 0);
		 //double nRatio=ratio*0.8;
		 //for (int dt=-5; dt<6; dt++)
		 //double rdt=dtCenter[setType][selected][s]-10*dtDelta;
		 double bestRatio=1.2;
		 //double bestDt=0;
		// rdt=-0.2;
		 
		 int iTry=0;
		 //rdt=-0.02*10;
		 int bestFactor=0;
		 int bestRange=0;
		 double dBisect=18;
		 double newtonV=18+s/2;
		 double newtonL=s+1;
		 double newtonU=s+36;
		 double lastV=0;
		 double nuV=0;
		 double nuP=pUBND;
		 double lastP=newtonV;
		 double delta=18;
		 newData[checkLen]=newtonV;
		 lastV=getDiff(adj, newData);
		 if (Math.abs(lastV)<0.01) diffAt[0]=(int)Math.round(newtonV);
		 
		 newData[checkLen]=newtonU;		 
		 nuV=getDiff(adj, newData);
		 if (Math.abs(nuV)<0.01) diffAt[0]=(int)Math.round(newtonV);
		 newData[checkLen]=newtonL;		 
		 double vL=getDiff(adj, newData);
		 if (Math.abs(vL)<0.01) diffAt[0]=(int)Math.round(newtonV);
		 if (diffAt[0] !=0) diff2=0.001;
		 else
		 {
			 if (Math.abs(nuV) < Math.abs(vL)) {
				 nuV=vL;
				 nuP=pLBND;
			 }
		 }
		 int iBsect=0;
		 while (diff2>0.01 && delta > 0.05 && iBsect < 6)// && expandFactor<13)
		 { 
			 //expandFactor += 1;
			 //sincRange=expandFactor*2;
			 
			// rdt += dtDelta;
			 //if (iTry > 40) 
				 //break;
			// double nRatio=ratio*(1+rdt);
			// iTry++;
			 //System.out.println("Line "+s+" use ratio "+nRatio);
		// for (int n4=1+s; n4<36+s; n4 += 36){//n4++){
			 //newData[38]=20;//n4;			 
			 //for (int n3=1+s; n3<36+s; n3++){
				// newData[37]=n3;				 
				// for (int n2=1+s; n2<36+s; n2++){
					 //newData[36]=n2;					 
					 //for (int n1=1+s; n1<36+s; n1++){
						 //newData[35]=newtonU;//n1;
			 double tmpP=(nuP*lastV - nuV*lastP)/(lastV - nuV);
			 if  (tmpP < pUBND && tmpP > pLBND) iBsect=0;
			 else
			 {
				 iBsect++;
				 if (tmpP > pUBND) {
					 if (nuV > lastV) tmpP=(pUBND+lastP)/2;
					 else tmpP=(pUBND+nuP)/2;
				 }
				 else {
					 if (nuV > lastV) tmpP=(pLBND+lastP)/2;
					 else tmpP=(pLBND+nuP)/2;
				 }	
			 }
			 lastV=nuV;
			 lastP=nuP;
			 nuP=tmpP;
			 
			 delta=Math.abs(nuP-lastP);
			 newData[checkLen]=nuP;	
			 nuV=getDiff(adj, newData);
			 diffAt[0]=(int)Math.round(nuP);
			 diff2=Math.abs(nuV);
		 }
		 checkCount=iCC;
		 //checkPositionStart=checkLen-1;
		 int verifyLen=checkLen;
		 
		 checkCount=chkCount;//verifyLen;
		 
		 checkPositionStart=verifyLen-1;
		 checkCount=chkCount;
		 
		 double v=getMeanError(0, checkCount, Arrays.copyOfRange(newData, checkLen-checkCount+1, checkLen+1), adj);
		 
		 merit_of_solution[s]=(1-v/errorRef);
				 //getDistance(newData[checkPositionStart], adj, Arrays.copyOfRange(newData, 0, verifyLen))/checkCount;	 
				 
		 
		// System.out.println
				 	//("Line "+s+" f="+expandFactor+" diff="
						 		//+dF.format(diff2)+" bf="+bestFactor+" range="+bestRange+ " r="+dF.format(bestRatio)+" @"+diffAt[0]);	 
				  
		 
		checkCount=chkCount;
		 //good1 += "("+diffAt[0]+","+diffAt[1]+","+diffAt[2]+","+diffAt[3]+")";
		 //good1 += " with diff="+dF.format(diff2);
		 //good1 += " has a="+dF.format(diff3[0])+" b="+dF.format(diff3[1])+" c="+dF.format(diff3[2]);
		
		//if (diff2 > 0.1) diffAt[0]=fineTuneHalfPrediction(s, oldSample.get(s), bestRatio, bestFactor, bestRange, diffAt[0], diff2);
		//if ()
		 //bestFitPoints[s]=diffAt[0];
	 }
	 checkCount=chkCount;	
	 return bestFitPoints;//retV;
}

int[] tryHalfSincFilter(Vector<int[]> oldSample, String fname){
	int byFactor=32;
	//Vector<double[]> sampled=oldSample;//expandSeries(byFactor,oldSample);
	//int iLen=sampled.get(0).length;
	//double pi=Math.PI;
	 //Vector<int[]> retV=new  Vector<int[]>();
	 int[] bestFitPoints=new int[5];
	// int orgCheckLen=36;
	  int checkLen=35;//orgCheckLen*byFactor;
	// double ratio;//=getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	// ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio /= 5;
	 //double[setType][sqz][reTryPoint]
	 //double[][][] dtStart={{9, -3, -1, -1, -1}, {-4, 5, 1, 1, 1}} ;
	// double[][][] dtCenter={{{0.04, 0.06, 0, 0.06, 0.16}, {0.08, 0.04, -0.18, -0.06, -0.18 }},
			// {{0.18, 0.02, 0.02, 0, 0.02}, {-0.18, -0.06, 0, 0, 0.02}}
	// } ;
	 //double[][] dtEnd={{11, -1, 1, 1, 1},  {-2, 7, 3, 3, 3}};
	 //double dtDelta=0.01;
	 	 
	// int selected=((int)sqz % 2);
	 BufferedWriter aWriter;
	 String fileName="tryExpandLog"+JackpotReader.drawDate+".txt";
	 try {
			aWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName)));	

	 for (int s=0; s<5; s++){
		 //aWriter.write("****************Checking line "+s);aWriter.newLine();
		 //String good1="try line "+s+" fits at ";
		 //ratio=getMeanRatio(Arrays.copyOfRange(sampled.get(s), iLen-checkLen, iLen));
		 int iLen=oldSample.get(s).length;
		 double[] newData=new double[checkLen+2];
			Arrays.fill(newData, 0);
		 for (int i=0; i<checkLen; i++){
			 newData[i]=oldSample.get(s)[iLen-checkLen+i];
		 }
		 double diff2=200000;
		 double[] diff3=new double[3];
		 diff3[2]=0;
		 diff3[1]=10;
		 diff3[0]=10;
		 int[] diffAt=new int[4];
		 //double nRatio=ratio*0.8;
		 //for (int dt=-5; dt<6; dt++)
		 //double rdt=dtCenter[setType][selected][s]-10*dtDelta;
		 double bestRatio=1.2;
		 //double bestDt=0;
		// rdt=-0.2;
		 
		 int iTry=0;
		 //rdt=-0.02*10;
		 int expandFactor=1;
		 int sincRange=expandFactor*2;
		 int bestFactor=0;
		 int bestRange=0;
		 while (diff2>0.001 && expandFactor<17)
		 { 
			 expandFactor++;
			 sincRange=expandFactor*2;
			 
			// rdt += dtDelta;
			 if (iTry > 40) 
				 break;
			// double nRatio=ratio*(1+rdt);
			 iTry++;
			 //System.out.println("Line "+s+" use ratio "+nRatio);
		 //for (int n4=1+s; n4<36+s; n4++){
			 //newData[38]=n4;			 
			 //for (int n3=1+s; n3<36+s; n3++){
				 //newData[37]=n3;				 
				 for (int n2=1+s; n2<36+s; n2++){
					 newData[36]=n2;					 
					 for (int n1=1+s; n1<36+s; n1++){
						 newData[35]=n1;
			 
			 double[] testData=expandSeries(expandFactor,newData); 
			 double adj=0;
			 int iCC=0;
			 for (int v=testData.length/16; v<testData.length*15/16; v++){
				 double tmp=triangleBySinc(v, sincRange, testData);
				 adj += (tmp/testData[v]);
				 iCC++;
			 }
			 adj /= iCC;
			 //adj *= 2;
			 double[] diffS=new double[3];
			 for (int ix=0; ix<checkCount; ix++){
				 int i=ix+36-checkCount;
				 int pos=i*expandFactor;
				 double conv=0;
				 
				 conv =triangleBySinc(pos, sincRange, testData)/adj;
				 //newData[i]=(int)Math.round(conv);
				 diffS[ix]=Math.abs(conv-testData[pos]);
				 //double ratio=Math.abs(conv)/sampled.get(s)[i];
			 }
		 
		 double tDiff=0;
		 for (int c=0; c<checkCount; c++)
		 {
		 	tDiff += diffS[c];
		 }
		 if (tDiff<0.005){
			 //aWriter.write("fit AT:("+n1+","+n2+","+n3+","+n4+") with "+diffS[0]+" and "+diffS[1]);
			 //aWriter.newLine(); 
		 } 
		 if (tDiff < diff2){
			 diff2=tDiff;
			 diff3[0]=diffS[0];
			 diff3[1]=diffS[1];
			 diff3[2]=diffS[2];
			 diffAt[0]=(int)Math.round(n1);
			 diffAt[1]=(int)Math.round(n2);;
			 //diffAt[2]=n3;
			 //diffAt[3]=n4;
			 bestRatio=adj;
			 //bestDt=nRatio/ratio;
			 bestFactor=expandFactor;
			 bestRange=sincRange;

		 }
					 }
				// }
			 //}
		 }
				 aWriter.write
				 //(good1+")"+bestRatio+"; n="+bestDt);aWriter.newLine();
				 //System.out.println
				 ("Line "+s+" f="+expandFactor+" diff="
						 		+dF.format(diff2)+" bf="+bestFactor+" range="+bestRange+ " r="+dF.format(bestRatio));	 
				 System.out.println
				 ("Line "+s+" f="+expandFactor+" diff="
						 		+dF.format(diff2)+" bf="+bestFactor+" range="+bestRange+ " r="+dF.format(bestRatio));	 
				  
		 }
		 
		 //good1 += "("+diffAt[0]+","+diffAt[1]+","+diffAt[2]+","+diffAt[3]+")";
		 //good1 += " with diff="+dF.format(diff2);
		 //good1 += " has a="+dF.format(diff3[0])+" b="+dF.format(diff3[1])+" c="+dF.format(diff3[2]);
		 aWriter.write
		 //(good1+")"+bestRatio+"; n="+bestDt);aWriter.newLine();
		 //System.out.println
		 ("!!!!Line "+s+" Best fit with diff="
				 		+dF.format(diff2)+" factor="+bestFactor+" range="+bestRange);
		 aWriter.newLine();
		 if (diff2 > 0.001) diffAt[0]=fineTuneTrianglePrediction(s, oldSample.get(s), bestRatio, bestFactor, bestRange, diffAt[0], diff2);
		 bestFitPoints[s]=diffAt[0];
	 }
		aWriter.close();
	} catch(IOException e){}
	 return bestFitPoints;//retV;
}

static int[] tryNewSample( Vector<int[]> sampled, String fname){
	int iLen=sampled.get(0).length;
	double pi=Math.PI;
	 Vector<int[]> retV=new  Vector<int[]>();
	 int[] bestFitPoints=new int[5];
	 int[] newData=new int[40];
	 int checkFrom=36;
	 double ratio;//=getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	// ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio += getMeanRatio(Arrays.copyOfRange(sampled.get(0), iLen-checkFrom, iLen));
	 //ratio /= 5;
	 //double[setType][sqz][reTryPoint]
	 //double[][][] dtStart={{9, -3, -1, -1, -1}, {-4, 5, 1, 1, 1}} ;
	 double[][][] dtCenter={{{0.04, 0.06, 0, 0.06, 0.16}, {0.08, 0.04, -0.18, -0.06, -0.18 }},
			 {{0.18, 0.02, 0.02, 0, 0.02}, {-0.18, -0.06, 0, 0, 0.02}}
	 } ;
	 //double[][] dtEnd={{11, -1, 1, 1, 1},  {-2, 7, 3, 3, 3}};
	 double dtDelta=0.02;
	 
	 
	 int selected=((int)sqz % 2);
	 BufferedWriter aWriter;
	 String fileName="C:\\Users\\eric\\workspace\\GetLottery\\539\\"+fname+checkCount+".txt";
	 try {
			aWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName)));	

	 for (int s=0; s<5; s++){
		 aWriter.write("****************Checking line "+s);aWriter.newLine();
		 String good1="try line "+s+" fits at ";
		 ratio=getMeanRatio(Arrays.copyOfRange(sampled.get(s), iLen-checkFrom, iLen));
		 Arrays.fill(newData, 0);
		 for (int i=0; i<35; i++){
			 newData[i]=sampled.get(s)[iLen-35+i];
		 }
		 double diff2=2000;
		 double[] diff3=new double[3];
		 diff3[2]=0;
		 diff3[1]=10;
		 diff3[0]=10;
		 int[] diffAt=new int[4];
		 //double nRatio=ratio*0.8;
		 //for (int dt=-5; dt<6; dt++)
		 double rdt=dtCenter[setType][selected][s]-10*dtDelta;
		 double bestRatio=1.2;
		 double bestDt=0;
		 rdt=-0.2;
		 boolean fixDt=false;
		 if (setType==0 && s==3 && sqz==3){
			 fixDt=true;
			 rdt=-0.06;
		 }
		 if (setType==1 && s==2 && sqz==3){
			 fixDt=true;
			 rdt=0.00;
		 }
		 int iTry=0;
		 rdt=-0.02*10;
		 while (diff2>0.01)
		 { 
			 //if (fixDt && iTry > 0) break;
			 //if (!fixDt) 
			 rdt += dtDelta;
			 if (iTry > 20) 
				 break;
			 double nRatio=ratio*(1+rdt);
			 iTry++;
			 //System.out.println("Line "+s+" use ratio "+nRatio);
		 for (int n4=1+s; n4<36+s; n4++){
			 newData[38]=n4;
			 for (int n3=1+s; n3<36+s; n3++){
				 newData[37]=n3;
				 for (int n2=1+s; n2<36+s; n2++){
					 newData[36]=n2;
					 
		 for (int n1=1+s; n1<36+s; n1++){
			 newData[35]=n1;
			  
			 double[] diffS=new double[3];
		 for (int ix=0; ix<checkCount; ix++){
			 int i=ix+36-checkCount;
			 double conv=0;
			 for (int k=1; k<6+1; k++){
				 //if (i+k<1) continue;
				 int t=i+(int)((k-1)/sqz);
				 if (t > newData.length-1) break;
				 //if (i+k >39) break;
				 conv += sinc40PI[Math.abs(k)]*newData[i+(int)((k-1)/sqz)]*2/pi;
			 }
			 for (int k=1; k<6+1; k++){
				 if (i- k < 0) break;
				 int t=i-(int)(k/sqz);
				 if (t<0) break;
				 //if (i+k > iLen) break;
				 conv += sinc40PI[Math.abs(k)]*newData[i-(int)(k/sqz)]*2/pi;
			 }
			 conv /= nRatio;//ratio;//1.795;//2.1174;//
			 //newData[i]=(int)Math.round(conv);
			 diffS[ix]=Math.abs(conv-newData[i]);
			 //double ratio=Math.abs(conv)/sampled.get(s)[i];
		 }
		 
		 double tDiff=0;
		 for (int c=0; c<checkCount; c++)
		 {
		 	tDiff += diffS[c];
		 }
		 if (tDiff<0.005){
			 aWriter.write("fit AT:("+n1+","+n2+","+n3+","+n4+") with "+diffS[0]+" and "+diffS[1]);
			 aWriter.newLine(); 
		 } 
		 if (tDiff < diff2){
			 diff2=tDiff;
			 diff3[0]=diffS[0];
			 diff3[1]=diffS[1];
			 diff3[2]=diffS[2];
			 diffAt[0]=n1;
			 diffAt[1]=n2;
			 diffAt[2]=n3;
			 diffAt[3]=n4;
			 bestRatio=nRatio;
			 bestDt=nRatio/ratio;

		 }
					 }
				 }
			 }
		 }
		 }
		 //meanDiff /= iLen;
		 //meanRatio /= iLen;
		 retV.add(Arrays.copyOf(newData, iLen));
		 good1 += "("+diffAt[0]+","+diffAt[1]+","+diffAt[2]+","+diffAt[3]+")";
		 good1 += " with diff="+dF.format(diff2);
		 good1 += " has a="+dF.format(diff3[0])+" b="+dF.format(diff3[1])+" c="+dF.format(diff3[2]);
		 aWriter.write(good1+")"+bestRatio+"; n="+bestDt);aWriter.newLine();
		 bestFitPoints[s]=diffAt[0];
	 }
		aWriter.close();
	}  catch (IOException e){
		return null;
	} 
	 return bestFitPoints;//retV;
}

static double getSincHighTerms(double x)//for n=7 and up
{
	double retV=1.0/7.0;
	retV -= ((x/9)*(x/9)/8);
	retV += ((x/11)*(x/11)*(x/10)*(x/9)/8);
	retV -= ((x/13)*(x/13)*(x/12)*(x/11)*(x/10)*(x/9)/8);
	for (int i=1; i<8; i++){
		retV *= (x/7);
	}
	return -1*retV;
}
static double tryMonte(int forN){
	double pi=Math.PI;
	double retV=0;
	for (int i=1; i<501; i++){
		double x=(forN+Math.random())*pi;
		for (int j=1; j<501; j++){
			double y=Math.random()/pi;
			if (y<= Math.abs(Math.sin(x)/x))
			retV += 1;
		}		
	}
	return retV/250000;
}

static void getSincData(){
	
	if (JackpotReader.sinc40PI[1]==0) JackpotReader.getSincData();
	sinc40PI=Arrays.copyOf(JackpotReader.sinc40PI, 58);
	double checkValue=0;
	/*
	BufferedWriter aWriter;
	boolean noFile=false;
	String fileName="sincTable";//C:\\Users\\eric\\workspace\\GetLottery\\sincTable.txt";
	//this file has the table list the integral from 0-pi, pi-2pi, 2pi-3pi .....
	Arrays.fill(sinc40PI, 0);
	
	double last1=0;
	BufferedReader mReader;
	try {
		mReader=new BufferedReader(new InputStreamReader(new FileInputStream(fileName)));	
		String aLine=null;
		int iC=0;
		do {
			aLine=mReader.readLine();
			if (aLine == null) break;
			String[] tmp=aLine.split(":");
			if (tmp.length<2){
				System.out.println(aLine+"!!!! wrong data missing :");
				continue;
			}
			int idx=++iC;//Integer.parseInt(tmp[0]);
			if (idx >-1 && idx < 60){
				//if (idx % 2 == 0)
			double sinc=Double.parseDouble(tmp[1]);
				
					sinc40PI[idx]=sinc - last1;	
				last1 = sinc;
			}
		} while (aLine != null);
		mReader.close();
	} catch (FileNotFoundException e){
		noFile=true;
	} catch (IOException e){
		if (sinc40PI[1]==0)
		noFile=true;
	}
	*/
	for (int i=0; i<sinc40PI.length; i++){
		checkValue += sinc40PI[i];
	}
	System.out.println("PI/2="+Math.PI/2+"Sum of Sinc is "+checkValue);
	if (sinc40PI[1]!=0) return;
	/*
	double pi=Math.PI;//22/7.0;
	double sinc0=0;
	for (int idx=1; idx < 40; idx++){
		double x=idx*pi;
		double sincX=x;
		double term=1;
		int k=2;
		//combine 2 terms to make the value smaller
		//k += 2;
		//each term -> x^(2k+1)/(2k+1)/(2k+1)! - x^(2k-1)/(2k-1)/(2k-1)!
		//             = x^(2k-1)[x^2/(2k+1)^2/2k/(2k-1)! - 1/(2k-1)/(2k-1)!]
		//             = x^(2k-1)/(2k-1)!*[x^2/(2k+1)^2/2k - 1/(2k-1)]
		if (idx > 10){
			sincX = sinc0;
			double m=1;
			if (k % 2==0) m = (-1);
			sincX += (m*tryMonte(idx));			
		} else {
		while (Math.abs(term) > 0.000001){
			term=1;
			term = 1.0/(2*k-1);			
			term -= (x*x)/(2*k*(2*k+1)*(2*k+1));
			for (int j=1; j<=2*k-1; j++){
				term *= (x/j);
			}
			//term /=(2*k+1);
			double m=1;
			//if (k % 2==1) m = (-1);
			sincX -= (m*term);
			k += 2;//++;
		}
		}
		sinc40PI[idx]=sincX - sinc0;
		checkValue += sinc40PI[idx];
		if (Math.abs(sincX-pi/2)<0.00001) break;
		sinc0=sincX;
	}
	try {
			aWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName)));	
			for (int i=0; i<40; i++){
				aWriter.write(""+i+":"+sinc40PI[i]);
				aWriter.newLine();
			}
			aWriter.close();
		}  catch (IOException e){
			return;
		}
		*/
	
	System.out.println("SINC table missing");
	System.exit(1);;
}


	static Vector<double[]> getRangePrimeFit(int range, Vector<int[]> inData){
		Vector<double[]> outResult=new Vector<double[]>();
		Vector<int[]> rangePrime=getPrimeData(inData);//getAscendPrimeData(inData);
		int iSet=inData.size();
		for (int s=0; s<iSet; s++){
		double[] iValue=new double[inData.get(0).length];
		Arrays.fill(iValue, 1);
			double iMax=39*range;
			double[] home=new double[range];
			for (int i=0; i<range; i++){
				home[i]=rangePrime.get(s)[i];
			}
			int k=inData.get(s).length;
			for (int i=6; i<k-range; i++){
			double primV=0;
					for (int n=0; n<range; n++){
						primV += Math.abs(rangePrime.get(s)[i+n]-home[n]);
					}
					iValue[i]=iMax-primV;
			}
			outResult.add(Arrays.copyOf(iValue, iValue.length));
		}
			
		return outResult;
	}

	String lineType;
	Vector<int[]> myCheckBackData;
	int myCheckBackStart;
	int myCheckBackEnd; //exclusive
	int checkBackOkCount;
	BufferedWriter checkFileLog;
	static final ReentrantReadWriteLock logLock=new ReentrantReadWriteLock();
	public boolean completeCheckBack;

	public void setParameter(Vector<int[]> thisData,int checkBackStart,	int checkBackEnd,//exclusive
			BufferedWriter log){
		myCheckBackData=new Vector<int[]>();
		for (int s=0; s<thisData.size(); s++){
			myCheckBackData.add(Arrays.copyOf(thisData.get(s), thisData.get(s).length));
		}
		myCheckBackStart=checkBackStart;
		myCheckBackEnd=checkBackEnd; //exclusive
		//int checkBackOkCount;
		checkFileLog=log;
		completeCheckBack=false;
	}
	
public void run(){
	
	double[] dd={1, 1.5};//2,3};//, 0.3, 0.5, 1, 1.5};
	int[] hitCount=new int[40];
	checkBackOkCount=0;
	System.out.println("start "+myCheckBackStart+" end "+myCheckBackEnd);//lineType);
	for (int ib=myCheckBackStart; ib<myCheckBackEnd; ib++){
		Vector<int[]> checkBackData=new Vector<int[]>();
		int[] target=new int[myCheckBackData.size()];
		for (int s=0; s<myCheckBackData.size(); s++){
			checkBackData.add(Arrays.copyOfRange(myCheckBackData.get(s), 0, ib));	
			target[s]=myCheckBackData.get(s)[ib];
		}
		Arrays.fill(hitCount, 0);
		
		for (int cc=2; cc<4; cc++){
			
			checkCount=cc;
			int byFactor=3;
			for (int i=0; i<dd.length; i++){
				sqz=dd[i];
				long tNow=System.currentTimeMillis();
				int[] orgF=//refineFound(dateAscend, "filterN"+(sqz*10)+lineType);//filterOutSample(dateAscend);;//
						tryExpanedSample(4, checkBackData, "filter"+byFactor+"X"+(sqz*10)+lineType);//filterOutSample(dateAscend);;//
				
				//System.out.println("Finish low pass try with "+
				                 //(System.currentTimeMillis() - tNow)+" milli secs");
				
				for (int s=0; s<checkBackData.size(); s++){
					hitCount[orgF[s]]++;
				}
			}
		}
		String targetLine="****** Line "+ib+"  .....Checking (";
		String foundLine="found (";
		String projectLine="projects (";
		int iFound=0;
		for (int idx=1; idx < 40; idx++){
			if (hitCount[idx]==0) continue;
			projectLine += ","+idx+"["+hitCount[idx]+"]";			
		}
		for (int s=0; s<checkBackData.size(); s++){
			targetLine += ""+target[s]+", ";
			if (hitCount[target[s]] == 0) continue;
			iFound++;
			foundLine += ""+target[s]+", ";				
		}
		logLock.writeLock().lock();
		if (iFound >0)
			checkOkTotall++;
		
		try {
			checkFileLog.write(targetLine+")");checkFileLog.newLine();
			checkFileLog.write(foundLine+")<"+iFound+">");checkFileLog.newLine();
			checkFileLog.write(projectLine+")");checkFileLog.newLine();
		}  catch (IOException e){			
		} 
		finally{
		logLock.writeLock().unlock();	
		}
	}
	completeCheckBack=true;
}

static double[][] getSincErrorTS(Vector<double[]> dateAscend){
	int iLen=dateAscend.get(0).length;
	double[][] retV=new double[5][iLen];
	for (int s=0; s<5; s++){
		retV[s][0]=0;
		for (int i=1; i<iLen-1; i++)
		retV[s][i]=(getSincConvolution(i, 54, Arrays.copyOf(dateAscend.get(s), i)) - dateAscend.get(s)[i+1]);
	}
	return retV;
}

static double[] getPrimeTS(double[] tsSample){
	double[] retV=new double[tsSample.length-1];
	for (int i=1; i<tsSample.length; i++)
		retV[i-1]=(tsSample[i]-tsSample[i-1]);
	return retV;
}
static double[] getNthDerivative(int n, double[] tsSample){
	//double retV=0;
	if (n > tsSample.length-1) return null;
	double[] tmp=tsSample;
	for (int i=0; i<n; i++){
		tmp=getPrimeTS(tmp);
	}
	return tmp;
}
static Vector<double[]> getNth0DerivativeTS(double[] tsSample){
	int iLen=tsSample.length;
	int checkPoint=iLen-1;
	Vector<double[]> tmpStorage=new Vector<double[]>();
	//Vector<double[]> derivativesTS=new Vector<double[]>();
	
	boolean found=false;
	double[] tmp=tsSample;
	while (!found){
		tmpStorage.add(tmp);
		if (tmp[tmp.length-2]*tmp[tmp.length-1] <= 0)break;
		tmp=getPrimeTS(tmp);
	}
	return tmpStorage;
}

public void drawFitCurve(int[] deltaData, String fileName)
{
	int width=600, height=500;
	BufferedImage bi=ImgFactory.getImg(width, height); //new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
	Graphics g=bi.getGraphics();
	drawSpecial=false;
	specialData=null;//deltaData;
	Vector<int[]> drawData=new Vector<int[]>();
	drawData.add(deltaData);
	getPngFile(bi, width, height, fileName, drawData);
	
}
public static double nthroot(int n, double A) {
	return nthroot(n, A, 0.001);
}
public static double nthroot1Percent(int n, double A) {
	double p=A/n*0.01;
	return nthroot(n, A, p);
}
public static double nthroot(int n, double A, double p) {
	if(A < 0) {
		System.err.println("A < 0");// we handle only real positive numbers
		return -1;
	} else if(A == 0) {
		return 0;
	}
	double x_prev = A;
	double x = A / n;  // starting "guessed" value...
	while(Math.abs(x - x_prev) > p) {
		x_prev = x;
		x = ((n - 1.0) * x + A / Math.pow(x, n - 1.0)) / n;
	}
	return x;
}

static int testCaseCount=JackpotReader.testCaseCount;
final static int SQUARE=0;
final static int LINEAR=1;
final static int PARAB=2;
final static int CUBIC=3;
final static int BETA12=13; //for y1-y0=(x/a)^(1/n)*(K-x/a)^(1/n); n=2, 3, 5
final static int BETA13=13;
final static int BETA15=15;
static double getPredictBy4PointsWith0Prime(double xMaximum, double[] xx, double[] y,  int fitMethod){
	//last2[last2.length-3], 1, last2[last2.length-2], 2, last2[last2.length-1]);
	double retV=0;
	int[] plotData=new int[60];
	
	if (fitMethod >= BETA12){
		double offsetValue=0;
		double weight=10;
		if (y[0] > y[1]) {
			if (y[2] > y[0]) offsetValue=y[2]+1;
			else offsetValue=y[0]+1;
			for (int i=0; i<3; i++) y[i]=offsetValue - y[i];
		}
		double w1=(y[1]-y[0])/weight;
		double w2=(y[2]-y[0])/weight;
		
		double d1=1;
		double d2=1;
		for (int i=0; i<fitMethod-10; i++) {
				d1 *= w1;
				d2 *= w2;
		}
		double d1n=d1;
		double d2n=d2;
		//if ()
		double a=Math.sqrt(2/(2*d1-d2));
		double k=(1/a+a*d1);
		double term1=(1/a);
		term1=nthroot1Percent(fitMethod-10, term1);
		double term2=k-1/a;
		if (term2 < 0) term2 = -1*nthroot1Percent(fitMethod-10, Math.abs(term2));
		else term2=nthroot1Percent(fitMethod-10, term2);
		double d10=weight*term1*term2+y[0];
		term1=(2/a);
		term1=nthroot1Percent(fitMethod-10, term1);
		term2=k-2/a;
		if (term2 < 0) term2 = -1*nthroot1Percent(fitMethod-10, Math.abs(term2));
		else term2=nthroot1Percent(fitMethod-10, term2);
		double d20=weight*term1*term2+y[0];
		term1=(3/a);
		term1=nthroot1Percent(fitMethod-10, term1);
		term2=k-3/a;		
		//if (fitMethod-10==2) term2=Math.sqrt(term2);
		if (term2 < 0) term2 = -1*nthroot1Percent(fitMethod-10, Math.abs(term2));
		else term2=nthroot1Percent(fitMethod-10, term2);
		
		retV=weight*term1*term2+y[0];
		/*
		int iEnd=(int)(k*a)+1;
		iEnd *= 10;
		plotData=new int[iEnd];
		for (int i=0; i<iEnd; i++){
			double x=i;
			x /=10;
			double term1=(x/a);
			//if (fitMethod-10==2)
				//term1=Math.sqrt(term1);
			//else 
				term1=nthroot1Percent(fitMethod-10, term1);
		term2=k-x/a;		
		//if (fitMethod-10==2) term2=Math.sqrt(term2);
		if (term2 < 0) term2 = -1*nthroot1Percent(fitMethod-10, Math.abs(term2));
		else term2=nthroot1Percent(fitMethod-10, term2);
		
			plotData[i]=(int)(weight*term1*term2+y[0]);
		
		}
		*/
		//HalfExpandedErrorTs aJob=new HalfExpandedErrorTs();
		//aJob.drawFitCurve(plotData, "tmpProjCurve"+fitMethod);
		/*
		int newMethod=fitMethod;

		double r1=y[1]-y[0];
		double r=1;
		for (int i=0; i<fitMethod-10; i++){
			r *= r1;
		}
		r1=r;
		double r2=y[2]-y[0];
		for (int i=0; i<fitMethod-10; i++){
			r *= r2;
		}
		r2=r;
		if (r2/2 > r1 && fitMethod==BETA12) {
			System.out.println("Cannot use beta 1/2 use 1/3 instead");
			r1 *= y[1]-y[0];
			r2 *= y[2]-y[0];
			newMethod += 1;
		}
		a=Math.sqrt(r1-r2/2);
		k=r1*a+1/a;
		double xM=(k-1)*a;
		double term1=(3/a);
			if (newMethod-10==2)
				term1=Math.sqrt(term1);
			else term1=nthroot1Percent(newMethod-10, term1);
		double term2=k-3/a;
		if (newMethod-10==2 && term2<0)
			return getPredictBy4PointsWith0Prime(xMaximum, xx, y,  BETA13);
		if (newMethod-10==2) term2=Math.sqrt(term2);
		else if (term2 < 0) term2 = -1*nthroot1Percent(newMethod-10, Math.abs(term2));
		else term2=nthroot1Percent(newMethod-10, term2);
		*/
		
		if (offsetValue > 0) retV=offsetValue - retV;
		return retV;
	}
	if (fitMethod==SQUARE){
		double yMaximum=(xMaximum-1)*(y[1]-y[0])/2+y[1];
		if (xMaximum<1)  yMaximum=(1-xMaximum)*(y[1]-y[2])/2+y[1];
		return yMaximum - (yMaximum - y[2])*(xMaximum - 3)/(xMaximum - 2);
		}
	if (fitMethod==LINEAR){
	double yMaximum=(xMaximum-1)*(y[1]-y[0])/2+y[1];
	if (xMaximum<1)  yMaximum=(1-xMaximum)*(y[1]-y[2])/2+y[1];
	return yMaximum - (yMaximum - y[2])*(xMaximum - 3)/(xMaximum - 2);
	}
	if (fitMethod==PARAB){
	double a=(y[0]+y[2])/2-y[1];
	double b=2*y[1]-y[0]-(y[0]+y[2])/2;
	double c=y[0];
	return a*(3*3*3)+b*(3*3)+c;
	}
	if (fitMethod==CUBIC){
		int n=4;
		double[][] rowCol=new double[n][n];
		for (int r=0; r<n-1; r++){				
			double[] col=rowCol[r];
			for (int v=0; v<n; v++){
				col[n-1-v]=1;
				for (int m=0; m<v; m++) col[n-1-v] *= xx[r];
			}
		}
		double[] colPrime=rowCol[n-1];
		colPrime[0]=3*xMaximum*xMaximum;
		colPrime[1]=2*xMaximum;
		colPrime[2]=1;
		colPrime[3]=0;
		Vector<double[]> mRow=new Vector<double[]>();	
		mRow.add(colPrime);
		mRow.add(rowCol[1]);
		mRow.add(rowCol[2]);
		mRow.add(rowCol[0]);
		MyMatrix mFit=new MyMatrix(mRow);
		MyMatrix iv=MyMatrix.inverseLU(mFit);
		if (iv==null){
			System.out.println("No inv matrix for cubic prediction use parab ");
			return getPredictBy4PointsWith0Prime(xMaximum, xx, y,  PARAB);
		}
		double[] yy=Arrays.copyOf(y, y.length+1);
		yy[y.length]=yy[0];
		yy[0]=0;
		double[] coeff=iv.multiply(yy);
		MyMatrix shouldBeI=iv.multiplyBy(mFit);
		retV=0;
		for (int i=0; i<coeff.length; i++){
			double nV=1;
			for (int v=0; v<n; v++){
				for (int m=0; m<v; m++) nV *= 3;
			}
			retV += coeff[i]*nV;
		}
		
		for (int i=0; i<40; i++){
			double x=i;
			x /=10;
			plotData[i]=(int)(coeff[0]*x*x*x+coeff[1]*x*x+coeff[2]*x+coeff[3]);
		}
	}
	//HalfExpandedErrorTs aJob=new HalfExpandedErrorTs();
	//aJob.drawFitCurve(plotData, "tmpProjCurve");
	return retV;
}

static double getPredictBy4PointsWith0Prime(double xMaximum, double x0, double y0, double x1, double y1, double x2, double y2, int fitMethod){
	//last2[last2.length-3], 1, last2[last2.length-2], 2, last2[last2.length-1]);
	double retV=0;
	if (fitMethod==LINEAR){
	double yMaximum=(xMaximum-1)*(y1-y0)/2+y1;
	if (xMaximum<1)  yMaximum=(1-xMaximum)*(y1-y2)/2+y1;
	return yMaximum - (yMaximum - y2)*(xMaximum -3)/(xMaximum - 2);
	}
	//if (fitMethod==PARAB){
	double a=(y0+y2)/2-y1;
	double b=2*y1-y0-(y0+y2)/2;
	double c=y0;
	return a*(3*3*3)+b*(3*3)+c;
	//}
	
}

static int[] predictByErrorFitting(double[][] predictionErrors, Vector<double[]> fTestData, int fitMethod){
	//double[][] predictionErrors=getSincErrorTS(fTestData);
	int[] retV=new int[5];
	for (int s=0; s<predictionErrors.length; s++){
		int iL=predictionErrors[s].length-1;
		//while (predictionErrors[s][iL])
		Vector<double[]> checkCureves=getNth0DerivativeTS(Arrays.copyOf(predictionErrors[s], predictionErrors[s].length-1));
		double[] last1=checkCureves.get(checkCureves.size()-1);
		double[] last2=fTestData.get(s);
		if (checkCureves.size() > 1) last2=checkCureves.get(checkCureves.size()-2);
		double x=Math.abs(last1[last1.length-2]/(last1[last1.length-2]-last1[last1.length-1]));
		//double 
		double[] xx={0, 1, 2};
		double[] yy={last2[last2.length-3], last2[last2.length-2], last2[last2.length-1]};
		double predict2=getPredictBy4PointsWith0Prime(2*x, xx, yy, fitMethod);
		double revV=predict2;
		for (int k=checkCureves.size()-3; k>=0 ; k--){
			revV += checkCureves.get(k)[0];
		}
		double e1=getSincConvolution(fTestData.get(s).length, 54, fTestData.get(s)) - revV;
		if (e1 <= 0) while (e1 < 0) e1 += 39;
		else while (e1 > 39) e1 -= 39;
		//System.out.println("get predic "+Math.round(e1));
		retV[s]=(int)Math.round(e1);
	}
	return retV;
}

static int[] fitMethods={LINEAR, BETA13, BETA15, PARAB, CUBIC};
static double[] adjustBasedOnHistoryDeviation(double[] historyErrorTS, double[] historicDraw){
	
	//int iL=historyErrorTS.length-1;
	//while (predictionErrors[s][iL])
	Vector<double[]> checkCureves=getNth0DerivativeTS(Arrays.copyOf(historyErrorTS, historyErrorTS.length-1));
	double[] last1=checkCureves.get(checkCureves.size()-1);
	double[] last2=historicDraw;
	if (checkCureves.size() > 1) last2=checkCureves.get(checkCureves.size()-2);
	double x=Math.abs(last1[last1.length-2]/(last1[last1.length-2]-last1[last1.length-1]));
	//double 
	double[] xx={0, 1, 2};
	double[] yy={last2[last2.length-3], last2[last2.length-2], last2[last2.length-1]};
	double[] predictsOnMethod=new double[fitMethods.length];
	for (int iMethod=0; iMethod < fitMethods.length; iMethod++){
		int fitMethod=fitMethods[iMethod];
	
	double predict2=getPredictBy4PointsWith0Prime(2*x, xx, yy, fitMethod);
	double revV=predict2;
	for (int k=checkCureves.size()-3; k>=0 ; k--){
		revV += checkCureves.get(k)[0];
	}
	//double e1=getSincConvolution(historicDraw.length, 54, historicDraw) - revV;
	//if (e1 <= 0) while (e1 < 0) e1 += 39;
	//else while (e1 > 39) e1 -= 39;
	//System.out.println("get predic "+Math.round(e1));
	predictsOnMethod[iMethod]=revV;//(int)Math.round(e1);
	}
	return predictsOnMethod;
}

static int checkOkTotall=0;
static Vector<int[]> globalSample=null;
static Vector<int[]> prime1=null;
static Vector<int[]> prime2=null;
static int setType=0;
public static void main(String[] args)
{
	getSincData();
	HashMap<String, Integer> caseCount=new HashMap<String, Integer>();
	//int[] setTypes={0, 1};
	//double[] dd={1, 1.5};//2,3};//, 0.3, 0.5, 1, 1.5};
	for (int iq=0; iq<2; iq++){
	//JackpotReader jReaderDrop=JackpotReader.getInstance("test539.txt","開出順序");//
	//Vector<int[]> dropData=jReaderDrop.readData(5, 39, 390);
	String[] criteria={"開出順序", "大小順序"};
	setType=iq;//setTypes[iq];
	String lineType=criteria[setType];
	JackpotReader jReaderOrder=JackpotReader.getInstance("test539.txt",lineType);//"開出順序");//"大小順序");//
	Vector<int[]> sampleData=jReaderOrder.readData(5, 39, 512);	
		globalSample=sampleData;
		int iLen1=sampleData.get(0).length;
		while (sampleData.get(0)[iLen1-1]==0) iLen1--;
		
		int[] testSeq=new int[iLen1];
		double[] fTestSeq=new double[iLen1];
		
		Vector<int[]> dateAscend=new Vector<int[]>();
		Vector<double[]> fDateAscend=new Vector<double[]>();
		for (int s=0; s<5; s++){
			for (int i=0; i<iLen1; i++){
				testSeq[i]=sampleData.get(s)[iLen1-1-i];
				fTestSeq[i]=sampleData.get(s)[iLen1-1-i];
			}
			dateAscend.add(Arrays.copyOf(testSeq, iLen1));
			fDateAscend.add(Arrays.copyOf(fTestSeq, iLen1));
		}
		
		Vector<double[]> fTestData=fDateAscend;
		double[][] predictionErrors=getSincErrorTS(fTestData);
		//int[] p1redictions=
				//predictByErrorFitting(predictionErrors, fTestData, fitMethod);
		//for (int i=0; i<p1redictions.length; i++) System.out.print(p1redictions[i]);
		//System.out.println();
		//int[] fitMethods={LINEAR, BETA13, BETA15, PARAB, CUBIC};//, BETA12};//PARAB, CUBIC};
		HalfExpandedErrorTs aJob=new HalfExpandedErrorTs();
		String myName=aJob.getClass().getName();
		int[] ccVal={3,4,5, 6};//4, 5, 6};//2, 3, 4, 5, 6};//,7,8,9};
		//int[][] mFreqs={{4,5,6,8}, {4,8}, {4,5,8}};//2, 3, 4, 5, 6};
		BufferedWriter aWriter=null;
		try {
			aWriter=new BufferedWriter(new OutputStreamWriter(
					new FileOutputStream("sincErrorFit"+lineType+JackpotReader.drawDate+"Log.txt")));	
			//chLog=new BufferedWriter(new OutputStreamWriter(
					//new FileOutputStream("half"+lineType+JackpotReader.drawDate+"TaiLog.txt"), "utf-8"));
			int iCheckEnd=iLen1;
			
			//try to add week day to the output
			//also include the value of other 6 points when it fits at new one
			//			
			int[][][] localPerformanceList=new int[fitMethods.length][6][testCaseCount];
			int[] ttPredicts=new int[fitMethods.length];
			int[] ttHits=new int[fitMethods.length];
			Arrays.fill(ttPredicts, 0);
			Arrays.fill(ttHits, 0);
			int[][] hitCounts=new int[fitMethods.length][6];
			int[][] lastHitLocation=new int[fitMethods.length][6];
			for (int iMd=0; iMd<fitMethods.length; iMd++){
				Arrays.fill(hitCounts[iMd], 0);
				Arrays.fill(lastHitLocation[iMd], 0);
				
				for (int x=0; x<6;x++)
					Arrays.fill(localPerformanceList[iMd][x], 0);
			}
			
			String[] showPredictions=new String[fitMethods.length];
			int[][][] predictionTS=new int[fitMethods.length][testCaseCount+1][];
			//Arrays.fill(predictionTS, 0);
			int confidentSampleLength=256;
			//while (iCheckStart <= iCheckEnd){
		for (int iTest=testCaseCount; iTest >=0; iTest--){
			aWriter.write(" ******** "+iTest+" ********");
			aWriter.newLine();
			//chLog.write(" ******** "+iTest+" ********");
			//chLog.newLine();
			
			int iFound=0;
			Vector<double[]> testData=new Vector<double[]>();
			int[] targets=new int[5];
			int[] found=new int[40];
			Arrays.fill(found, 0);
			String showDraw="Draw=(";
			int targetLoc=iLen1-iTest;
			double[][] testErrorList=new double[predictionErrors.length][];
			for (int s=0; s<predictionErrors.length; s++)
			{
				testErrorList[s]=Arrays.copyOfRange(predictionErrors[s], 0, targetLoc);// targetLoc-confidentSampleLength, targetLoc);//0, iCheckStart));
				
				testData.add(Arrays.copyOfRange(fDateAscend.get(s), 0, targetLoc));//targetLoc-confidentSampleLength, targetLoc));//0, iCheckStart));
				if (iTest > 0)
				targets[s]=dateAscend.get(s)[targetLoc];
				else
					targets[s]=0;
				showDraw += " "+targets[s]+", ";
			}
			
			aWriter.write(showDraw);
			aWriter.newLine();
			if (iTest==0)
				aWriter.newLine();
			
			for (int iMd=0; iMd<fitMethods.length; iMd++){
				int which1=fitMethods[iMd];
				String sFreq="";
				aJob.expandedBy=which1;
				int[] guessList=new int[40];
				Arrays.fill(guessList, 0);
				
				long tNow=System.currentTimeMillis();
				
				int[] predictions=predictByErrorFitting(testErrorList, testData, which1);
				
				for (int k=0; k<predictions.length; k++){
					if (predictions[k] > 39) predictions[k] -= 39;
					else if (predictions[k] < 1) predictions[k] += 39;
					guessList[predictions[k]]=1;
				}
					
				
				showPredictions[iMd]="has predic=(";
				for (int i=1; i<40; i++){
					if (guessList[i]>0) {
						showPredictions[iMd] += " "+i+", ";
						ttPredicts[iMd] ++;
					}
				}
				String showHit="Freq= "+which1+" ---found :(";
				String foundTxt="good pred: (";
				int goodOne=0;
				iFound=0;
				for (int p=0; p<5; p++){
					//testTxt += ""+targets[p]+",";
					if (guessList[targets[p]]>0){
						iFound++;
						showHit += ""+targets[p]+", ";
					}
				}
				int pCount=0;
				for (int k=0; k<guessList.length; k++)
					if (guessList[k]==1) 
						{
							//sPred += ""+k+", ";
							guessList[pCount++]=k;
						}
				int[] pList=Arrays.copyOf(guessList, pCount);
				predictionTS[iMd][testCaseCount-iTest]=pList;
				ttHits[iMd] += iFound;
				aWriter.write(showHit+">>>"+iFound);
				aWriter.newLine();
				
				aWriter.write(showPredictions[iMd]+")");
				aWriter.newLine();
				aWriter.write("--------------------------------------");
				aWriter.newLine();
			
			hitCounts[iMd][iFound]++;
			if (iTest > 0 )
				lastHitLocation[iMd][iFound]=	iTest;
			if (iTest>0)
				localPerformanceList[iMd][iFound][testCaseCount-iTest]=1;
		}
		}
		
		JackpotReader.showSummaryPage(predictionTS, hitCounts, lastHitLocation, localPerformanceList, myName, aWriter);
		
		
		aWriter.close();
		
		//chLog.close();
		}catch (IOException e){}
		
		
	}
}


}
